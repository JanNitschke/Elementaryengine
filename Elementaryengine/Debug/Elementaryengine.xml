<?xml version="1.0"?>
<doc>
    <assembly>
        "Elementaryengine"
    </assembly>
    <members>
        <member name="F:Game.oldTime">
            <summary>
Time from the start of the game to the last frame in ms
</summary>
        </member>
        <member name="F:Game.currentTime">
            <summary>
Time since start of the game in ms
</summary>
        </member>
        <member name="M:Game.#ctor">
            <summary>
Private constructor. Use shared_instance() to get the instance. Only one instance can exist simultaneously
</summary>
        </member>
        <member name="M:Game.netDisconnect">
            <summary>
Disconnect from Server
</summary>
        </member>
        <member name="M:Game.netConnect(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
            <summary>
Connect to Server
</summary>
            <param name="ip">
adress to connect to
</param>
        </member>
        <member name="M:Game.updateNetwork">
            <summary>
Called inside the loop if multiplayer is enabled to send and recive network data.
</summary>
        </member>
        <member name="F:Game.directionalLightDirection">
            <summary>
Direction of the directional light
</summary>
        </member>
        <member name="F:Game.directionalLightColor">
            <summary>
Color Of the directional light. default: vec3(0) for no light
</summary>
        </member>
        <member name="M:Game.LoadScene">
            <summary>
Loads the Scene from the Gamemode
</summary>
        </member>
        <member name="M:Game.RenderHUD">
            <summary>
Renders the HUD
</summary>
        </member>
        <member name="M:Game.processInput(GLFWwindow*)">
            <summary>
Handles the input of the window and passes it to the active Gamemode. Not used atm
</summary>
            <param name="window">
The window to fetch the input from
</param>
        </member>
        <member name="M:Game.RenderShadowMaps">
            <summary>
Renders the shadow maps of all lights
</summary>
        </member>
        <member name="M:Game.RenderEnvironmentMaps">
            <summary>
Renders the environment maps of all elements of the assets vector wich have set "renderEnvironment" to true
</summary>
        </member>
        <member name="M:Game.Render">
            <summary>
Draws all elements of the assets vector
</summary>
        </member>
        <member name="M:Game.setLight(glm.tvec3&lt;System.Single,0x0&gt;,glm.tvec3&lt;System.Single,0x0&gt;)">
            <summary>
Set the directional light color and direction
</summary>
        </member>
        <member name="M:Game.loop">
            <summary>
Main loop of the game
</summary>
        </member>
        <member name="M:Game.Stop">
            <summary>
Stops the gameand exits main loop
</summary>
        </member>
        <member name="M:Game.Start">
            <summary>
Starts the game and runs the main loop
</summary>
        </member>
        <member name="F:Game.deltaTime">
            <summary>
Time since last frame
</summary>
        </member>
        <member name="F:Game.smoothFps">
            <summary>
Smoothed FPS counter
</summary>
        </member>
        <member name="F:Game.View">
            <summary>
View matrix for the 3D scene;
</summary>
        </member>
        <member name="F:Game.Projection">
            <summary>
Projection matrix for 3D scene;
</summary>
        </member>
        <member name="F:Game.lamps">
            <summary>
Lamps to render (need to be atached to an asset or will throw error)
</summary>
        </member>
        <member name="F:Game.nextAssets">
            <summary>
Assets to loop trough next frame. You may delete items from this, but the destructor usualy does this by itself.
</summary>
        </member>
        <member name="F:Game.assets">
            <summary>
Assets to loop trough this frame. DO NOT DELETE FROM THIS! Created assets register themselfs here.
</summary>
        </member>
        <member name="M:Game.SetActiveCam(Camera*)">
            <summary>
Set the currently used camera
</summary>
        </member>
        <member name="F:Game.activeCam">
            <summary>
The active camera
</summary>
        </member>
        <member name="F:Game.windowHeight">
            <summary>
Stops the gameand exits main loop
</summary>
        </member>
        <member name="F:Game.requireServer">
            <summary>
Is this a multiplayer Game that requires a server 
</summary>
        </member>
        <member name="M:Game.setIsServer(System.Boolean)">
            <summary>
Use this to set the isServer variable
</summary>
        </member>
        <member name="F:Game.isServer">
            <summary>
Is this instance a client or a Server.
</summary>
        </member>
        <member name="F:Game.name">
            <summary>
Name of the game and window title
</summary>
        </member>
        <member name="F:Game.gameMode">
            <summary>
The Gamemode to load
</summary>
        </member>
        <member name="F:Game.window">
            <summary>
The GLFW handle of the main window
</summary>
        </member>
        <member name="M:Game.Dispose">
            <summary>
DO NOT DESTROY THE GAME OBJECT WITHOUT CALLING Game::Stop() FIRST!
</summary>
        </member>
        <member name="T:RaycastHit">
            <summary>
Game class abstracts all things that belong to the game. Run Start() after creating an instance to run the game. Do not forget to set the window options and gamemode first.
You can not create more than one instance of this class;
</summary>
        </member>
        <member name="M:btConvexConvexAlgorithm.#ctor(btPersistentManifold*,btCollisionAlgorithmConstructionInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btCollisionObjectWrapper!System.Runtime.CompilerServices.IsConst*,btCollisionObjectWrapper!System.Runtime.CompilerServices.IsConst*,btConvexPenetrationDepthSolver*,System.Int32,System.Int32)">
cache separating vector to speedup collision detection
</member>
        <member name="M:btPolyhedralContactClipping.clipFace(btAlignedObjectArray&lt;btVector3&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btAlignedObjectArray&lt;btVector3&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
the clipFace method is used internally
</member>
        <member name="T:btConvexPolyhedron">
This file was written by Erwin Coumans
</member>
        <member name="M:btGjkPairDetector.setIgnoreMargin(System.Boolean)">
don't use setIgnoreMargin, it's for Bullet's internal use
</member>
        <member name="T:btGjkPairDetector">
btGjkPairDetector uses GJK to implement the btDiscreteCollisionDetectorInterface
</member>
        <member name="T:btVoronoiSimplexSolver">
btVoronoiSimplexSolver is an implementation of the closest point distance algorithm from a 1-4 points simplex to the origin.
Can be used with GJK, as an alternative to Johnson distance algorithm.
</member>
        <member name="T:btUsageBitfield">
disable next define, or use defaultCollisionConfiguration-&gt;getSimplexSolver()-&gt;setEqualVertexThreshold(0.f) to disable/configure
</member>
        <member name="T:btGImpactMeshShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btGImpactMeshShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btGImpactQuantizedBvh.update">
@{
</member>
        <member name="T:BT_QUANTIZED_BVH_NODE">
btQuantizedBvhNode is a compressed aabb node, 16 bytes.
Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
</member>
        <member name="M:btGImpactBvh.update">
@{
</member>
        <member name="T:GIM_BVH_DATA">
GIM_BVH_DATA is an internal GIMPACT collision structure to contain axis aligned bounding box
</member>
        <member name="M:bt_edge_plane(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector4*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calc a plane from a triangle edge an a normal. plane is a vec4f
</member>
        <member name="T:btGeometryUtil">
The btGeometryUtil helper class provides a few methods to convert between plane equations and vertices.
</member>
        <member name="T:eBT_PLANE_INTERSECTION_TYPE">
Swap numbers
</member>
        <member name="M:btRaycastVehicle.getUserConstraintType">
backwards compatibility
</member>
        <member name="M:btRaycastVehicle.getCurrentSpeedKmHour">
Velocity of vehicle (positive if velocity vector has same direction as foward vector)
</member>
        <member name="M:btRaycastVehicle.getForwardVector">
Worldspace forward vector
</member>
        <member name="M:btRaycastVehicle.debugDraw(btIDebugDraw*)">
btActionInterface interface
</member>
        <member name="M:btRaycastVehicle.updateAction(btCollisionWorld*,System.Single)">
btActionInterface interface
</member>
        <member name="F:btRaycastVehicle.m_userConstraintType">
backwards compatibility
</member>
        <member name="T:btRaycastVehicle">
rayCast vehicle, very special constraint that turn a rigidbody into a vehicle.
</member>
        <member name="T:btActionInterface">
Basic interface to allow actions such as vehicles and characters to be updated inside a btDynamicsWorld
</member>
        <member name="T:btWheelInfo">
btWheelInfo contains information per wheel about friction and suspension.
</member>
        <member name="T:btVehicleRaycaster">
btVehicleRaycaster is provides interface for between vehicle simulation and raycasting
</member>
        <member name="M:btSequentialImpulseConstraintSolver.getScalarConstraintRowSolverLowerLimit">
Various implementations of solving a single constraint row using an inequality (lower limit) constraint, using scalar reference, SSE2 or SSE4
</member>
        <member name="M:btSequentialImpulseConstraintSolver.getScalarConstraintRowSolverGeneric">
Various implementations of solving a single constraint row using a generic equality constraint, using scalar reference, SSE2 or SSE4
</member>
        <member name="M:btSequentialImpulseConstraintSolver.reset">
clear internal cached data and reset random seed
</member>
        <member name="F:btSequentialImpulseConstraintSolver.m_btSeed2">
m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
</member>
        <member name="T:btSequentialImpulseConstraintSolver">
The btSequentialImpulseConstraintSolver is a fast SIMD implementation of the Projected Gauss Seidel (iterative LCP) method.
</member>
        <member name="M:btConstraintSolver.reset">
clear internal cached data and reset random seed
</member>
        <member name="T:btConstraintSolverType">
btConstraintSolver provides solver interface
</member>
        <member name="T:btGearConstraintFloatData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btGearConstraint.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btGearConstraint.getParam(System.Int32,System.Int32)">
return the local value of parameter
</member>
        <member name="M:btGearConstraint.getInfo2(btTypedConstraint.btConstraintInfo2*)">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="M:btGearConstraint.getInfo1(btTypedConstraint.btConstraintInfo1*)">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="T:btGearConstraint">
The btGeatConstraint will couple the angular velocity for two bodies around given local axis and ratio.
See Bullet/Demos/ConstraintDemo for an example use.
</member>
        <member name="T:btUniversalConstraint">
Constraint similar to ODE Universal Joint
has 2 rotatioonal degrees of freedom, similar to Euler rotations around Z (axis 1)
and Y (axis 2)
Description from ODE manual : 
"Given axis 1 on body 1, and axis 2 on body 2 that is perpendicular to axis 1, it keeps them perpendicular. 
In other words, rotation of the two bodies about the direction perpendicular to the two axes will be equal."
</member>
        <member name="M:btGeneric6DofSpringConstraint.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="T:btGeneric6DofSpringConstraint">
Generic 6 DOF constraint that allows to set spring motors to any translational and rotational DOF
DOF index used in enableSpring() and setStiffness() means:
0 : translation X
1 : translation Y
2 : translation Z
3 : rotation X (3rd Euler rotational around new position of X axis, range [-PI+epsilon, PI-epsilon] )
4 : rotation Y (2nd Euler rotational around new position of Y axis, range [-PI/2+epsilon, PI/2-epsilon] )
5 : rotation Z (1st Euler rotational around Z axis, range [-PI+epsilon, PI-epsilon] )
</member>
        <member name="T:btSliderConstraintData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btSliderConstraint.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btSliderConstraint.getParam(System.Int32,System.Int32)">
return the local value of parameter
</member>
        <member name="M:btSliderConstraint.setParam(System.Int32,System.Single,System.Int32)">
override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
If no axis is provided, it uses the default axis for this constraint.
</member>
        <member name="F:btSliderConstraint.m_useSolveConstraintObsolete">
for backwards compatibility during the transition to 'getInfo/getInfo2'
</member>
        <member name="M:btGeneric6DofConstraint.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btGeneric6DofConstraint.getParam(System.Int32,System.Int32)">
return the local value of parameter
</member>
        <member name="M:btGeneric6DofConstraint.setParam(System.Int32,System.Single,System.Int32)">
override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
If no axis is provided, it uses the default axis for this constraint.
</member>
        <member name="F:btGeneric6DofConstraint.m_useSolveConstraintObsolete">
for backwards compatibility during the transition to 'getInfo/getInfo2'
</member>
        <member name="T:btGeneric6DofConstraint">
btGeneric6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
</member>
        <member name="T:btConeTwistConstraintData">
this structure is not used, except for loading pre-2.82 .bullet files
</member>
        <member name="M:btConeTwistConstraint.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btConeTwistConstraint.getParam(System.Int32,System.Int32)">
return the local value of parameter
</member>
        <member name="M:btConeTwistConstraint.setParam(System.Int32,System.Single,System.Int32)">
override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
If no axis is provided, it uses the default axis for this constraint.
</member>
        <member name="T:btConeTwistConstraint">
btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc)
</member>
        <member name="T:btHingeConstraintDoubleData2">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btHingeAccumulatedAngleConstraint">
The getAccumulatedHingeAngle returns the accumulated hinge angle, taking rotation across the -PI/PI boundary into account
</member>
        <member name="T:btHingeConstraintDoubleData">
this structure is not used, except for loading pre-2.82 .bullet files
</member>
        <member name="M:btHingeConstraint.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btHingeConstraint.getParam(System.Int32,System.Int32)">
return the local value of parameter
</member>
        <member name="M:btHingeConstraint.setParam(System.Int32,System.Single,System.Int32)">
override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
If no axis is provided, it uses the default axis for this constraint.
</member>
        <member name="M:btHingeConstraint.getHingeAngle">
The getHingeAngle gives the hinge angle in range [-PI,PI]
</member>
        <member name="T:btHingeConstraint">
hinge constraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
axis defines the orientation of the hinge axis
</member>
        <member name="T:btPoint2PointConstraintDoubleData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
this structure is not used, except for loading pre-2.82 .bullet files
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btPoint2PointConstraintDoubleData2">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btPoint2PointConstraintFloatData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btPoint2PointConstraint.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btPoint2PointConstraint.getParam(System.Int32,System.Int32)">
return the local value of parameter
</member>
        <member name="M:btPoint2PointConstraint.setParam(System.Int32,System.Single,System.Int32)">
override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
If no axis is provided, it uses the default axis for this constraint.
</member>
        <member name="F:btPoint2PointConstraint.m_useSolveConstraintObsolete">
for backwards compatibility during the transition to 'getInfo/getInfo2'
</member>
        <member name="T:btPoint2PointConstraint">
point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space
</member>
        <member name="M:btAngularLimit.getError">
Returns correction value multiplied by sign value
</member>
        <member name="M:btAngularLimit.fit(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
returned is modified so it equals to the limit closest to given angle.
</member>
        <member name="M:btAngularLimit.isLimit">
Returns true when the last test() invocation recognized limit violation
</member>
        <member name="M:btAngularLimit.getHalfRange">
Gives half of the distance between min and max limit angle
</member>
        <member name="M:btAngularLimit.getSign">
Returns sign value evaluated when test() was invoked 
</member>
        <member name="M:btAngularLimit.getCorrection">
Returns correction value evaluated when test() was invoked 
</member>
        <member name="M:btAngularLimit.getRelaxationFactor">
Returns limit's relaxation factor
</member>
        <member name="M:btAngularLimit.getBiasFactor">
Returns limit's bias factor
</member>
        <member name="M:btAngularLimit.getSoftness">
Returns limit's softness
</member>
        <member name="M:btAngularLimit.test(System.Single!System.Runtime.CompilerServices.IsConst)">
Checks conastaint angle against limit. If limit is active and the angle violates the limit
correction is calculated.
</member>
        <member name="M:btAngularLimit.set(System.Single,System.Single,System.Single,System.Single,System.Single)">
Sets all limit's parameters.
When low &gt; high limit becomes inactive.
When high - low &gt; 2PI limit is ineffective too becouse no angle can exceed the limit
</member>
        <member name="M:btAngularLimit.#ctor">
Default constructor initializes limit as inactive, allowing free constraint movement
</member>
        <member name="T:btTypedConstraintData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
this structure is not used, except for loading pre-2.82 .bullet files
</member>
        <member name="T:btTypedConstraintFloatData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btTypedConstraint.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btTypedConstraint.getParam(System.Int32,System.Int32)">
return the local value of parameter
</member>
        <member name="M:btTypedConstraint.setParam(System.Int32,System.Single,System.Int32)">
override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). 
If no axis is provided, it uses the default axis for this constraint.
</member>
        <member name="M:btTypedConstraint.getAppliedImpulse">
getAppliedImpulse is an estimated total applied impulse. 
This feedback could be used to determine breaking constraints or playing sounds.
</member>
        <member name="M:btTypedConstraint.enableFeedback(System.Boolean)">
enableFeedback will allow to read the applied linear and angular impulse
use getAppliedImpulse, getAppliedLinearImpulse and getAppliedAngularImpulse to read feedback information
</member>
        <member name="M:btTypedConstraint.solveConstraintObsolete(btSolverBody*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btSolverBody*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="M:btTypedConstraint.internalGetAppliedImpulse">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="M:btTypedConstraint.internalSetAppliedImpulse(System.Single)">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="M:btTypedConstraint.getInfo2(btTypedConstraint.btConstraintInfo2*)">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="M:btTypedConstraint.getInfo1(btTypedConstraint.btConstraintInfo1*)">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="M:btTypedConstraint.setupSolverConstraint(btAlignedObjectArray&lt;btSolverConstraint&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Single)">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="M:btTypedConstraint.buildJacobian">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="M:btTypedConstraint.setOverrideNumSolverIterations(System.Int32)">
override the number of constraint solver iterations used to solve this constraint
-1 will use the default number of iterations, as specified in SolverInfo.m_numIterations
</member>
        <member name="M:btTypedConstraint.getMotorFactor(System.Single,System.Single,System.Single,System.Single,System.Single)">
internal method used by the constraint solver, don't use them directly
</member>
        <member name="T:btTypedConstraint">
TypedConstraint is the baseclass for Bullet constraints and vehicles
</member>
        <member name="T:btSolverConstraint">
1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
</member>
        <member name="M:btSolverBody.internalGetDeltaLinearVelocity">
some internal methods, don't use them
</member>
        <member name="T:btSolverBody">
The btSolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
</member>
        <member name="M:op_Addition(btSimdScalar!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btSimdScalar!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the elementwise product of two btSimdScalar
</member>
        <member name="M:op_Multiply(btSimdScalar!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btSimdScalar!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the elementwise product of two btSimdScalar
</member>
        <member name="T:btSimdScalar">
Until we get other contributions, only use SIMD on Windows, when using Visual Studio 2008 or later, and not double precision
</member>
        <member name="T:btJacobianEntry">
Jacobian entry is an abstraction that allows to describe constraints
it can be used in combination with a constraint solver
Can be used to relate the effect of an impulse to the constraint error
</member>
        <member name="T:btRigidBodyDoubleData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btRigidBodyFloatData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btRigidBody.computeGyroscopicForceExplicit(System.Single)">
explicit version is best avoided, it gains energy
</member>
        <member name="M:btRigidBody.computeGyroscopicImpulseImplicit_Body(System.Single)">
perform implicit force computation in body space (inertial frame)
</member>
        <member name="M:btRigidBody.computeGyroscopicImpulseImplicit_World(System.Single)">
perform implicit force computation in world space
</member>
        <member name="M:btRigidBody.predictIntegratedTransform(System.Single,btTransform*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
continuous collision detection needs prediction
</member>
        <member name="M:btRigidBody.upcast(btCollisionObject!System.Runtime.CompilerServices.IsConst*)">
to keep collision detection and dynamics separate we don't store a rigidbody pointer
but a rigidbody is derived from btCollisionObject, so we can safely perform an upcast
</member>
        <member name="M:btRigidBody.setupRigidBody(btRigidBody.btRigidBodyConstructionInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
setupRigidBody is only used internally by the constructor
</member>
        <member name="M:btRigidBody.#ctor(System.Single,btMotionState*,btCollisionShape*,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
btRigidBody constructor for backwards compatibility. 
To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)
</member>
        <member name="M:btRigidBody.#ctor(btRigidBody.btRigidBodyConstructionInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
btRigidBody constructor using construction info
</member>
        <member name="F:btRigidBody.btRigidBodyConstructionInfo.m_restitution">
best simulation results using zero restitution.
</member>
        <member name="F:btRigidBody.btRigidBodyConstructionInfo.m_rollingFriction">
the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
See Bullet/Demos/RollingFrictionDemo for usage
</member>
        <member name="F:btRigidBody.btRigidBodyConstructionInfo.m_friction">
best simulation results when friction is non-zero
</member>
        <member name="F:btRigidBody.btRigidBodyConstructionInfo.m_motionState">
When a motionState is provided, the rigid body will initialize its world transform from the motion state
In this case, m_startWorldTransform is ignored.
</member>
        <member name="T:btRigidBody.btRigidBodyConstructionInfo">
The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
You can use the motion state to synchronize the world transform between physics and graphics objects. 
And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
m_startWorldTransform is only used when you don't provide a motion state.
</member>
        <member name="T:btRigidBody">
The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
There are 3 types of rigid bodies: 
- A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
- B) Fixed objects with zero mass. They are not moving (basically collision objects)
- C) Kinematic objects, which are objects without mass, but the user can move them. There is on-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)

2009 March: btGeneric6DofConstraint refactored by Roman Ponomarev
Added support for generic constraint solver through getInfo1/getInfo2 methods

2009 March: btGeneric6DofConstraint refactored by Roman Ponomarev
Added support for generic constraint solver through getInfo1/getInfo2 methods
</member>
        <member name="F:BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT">
BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
</member>
        <member name="M:btSimpleDynamicsWorld.removeCollisionObject(btCollisionObject*)">
removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
</member>
        <member name="M:btSimpleDynamicsWorld.stepSimulation(System.Single,System.Int32,System.Single)">
maxSubSteps/fixedTimeStep for interpolation is currently ignored for btSimpleDynamicsWorld, use btDiscreteDynamicsWorld instead
</member>
        <member name="M:btSimpleDynamicsWorld.#ctor(btDispatcher*,btBroadphaseInterface*,btConstraintSolver*,btCollisionConfiguration*)">
this btSimpleDynamicsWorld constructor creates dispatcher, broadphase pairCache and constraintSolver
</member>
        <member name="T:btSimpleDynamicsWorld">
The btSimpleDynamicsWorld serves as unit-test and to verify more complicated and optimized dynamics worlds.
Please use btDiscreteDynamicsWorld instead
</member>
        <member name="M:btDiscreteDynamicsWorld.setLatencyMotionStateInterpolation(System.Boolean)">
Interpolate motion state between previous and current transform, instead of current and next transform.
This can relieve discontinuities in the rendering, due to penetrations
</member>
        <member name="M:btDiscreteDynamicsWorld.serialize(btSerializer*)">
Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (see Bullet/Demos/SerializeDemo)
</member>
        <member name="M:btDiscreteDynamicsWorld.removeCharacter(btActionInterface*)">
obsolete, use removeAction instead
</member>
        <member name="M:btDiscreteDynamicsWorld.addCharacter(btActionInterface*)">
obsolete, use addAction instead
</member>
        <member name="M:btDiscreteDynamicsWorld.removeVehicle(btActionInterface*)">
obsolete, use removeAction instead
</member>
        <member name="M:btDiscreteDynamicsWorld.addVehicle(btActionInterface*)">
obsolete, use addAction instead
</member>
        <member name="M:btDiscreteDynamicsWorld.updateVehicles(System.Single)">
obsolete, use updateActions instead
</member>
        <member name="M:btDiscreteDynamicsWorld.applyGravity">
apply gravity, call this once per timestep
</member>
        <member name="M:btDiscreteDynamicsWorld.clearForces">
the forces on each rigidbody is accumulating together with gravity. clear this after each timestep.
</member>
        <member name="M:btDiscreteDynamicsWorld.removeCollisionObject(btCollisionObject*)">
removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
</member>
        <member name="M:btDiscreteDynamicsWorld.synchronizeSingleMotionState(btRigidBody*)">
this can be useful to synchronize a single rigid body -&gt; graphics object
</member>
        <member name="M:btDiscreteDynamicsWorld.stepSimulation(System.Single,System.Int32,System.Single)">
if maxSubSteps &gt; 0, it will interpolate motion between fixedTimeStep's
</member>
        <member name="M:btDiscreteDynamicsWorld.#ctor(btDispatcher*,btBroadphaseInterface*,btConstraintSolver*,btCollisionConfiguration*)">
this btDiscreteDynamicsWorld constructor gets created objects from the user, and will not delete those
</member>
        <member name="T:btDiscreteDynamicsWorld">
btDiscreteDynamicsWorld provides discrete rigid body simulation
those classes replace the obsolete CcdPhysicsEnvironment/CcdPhysicsController
</member>
        <member name="T:btSpinMutex">

btSpinMutex -- lightweight spin-mutex implemented with atomic ops, never puts
              a thread to sleep because it is designed to be used with a task scheduler
              which has one thread per core and the threads don't sleep until they
              run out of tasks. Not good for general purpose use.

</member>
        <member name="T:btDynamicsWorldFloatData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btDynamicsWorldDoubleData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btDynamicsWorld.removeCharacter(btActionInterface*)">
obsolete, use removeAction instead
</member>
        <member name="M:btDynamicsWorld.addCharacter(btActionInterface*)">
obsolete, use addAction instead.
</member>
        <member name="M:btDynamicsWorld.removeVehicle(btActionInterface*)">
obsolete, use removeAction instead
</member>
        <member name="M:btDynamicsWorld.addVehicle(btActionInterface*)">
obsolete, use addAction instead.
</member>
        <member name="M:btDynamicsWorld.setInternalTickCallback(=FUNC:System.Void(btDynamicsWorld*,System.Single),System.Void*,System.Boolean)">
Set the callback for when an internal tick (simulation substep) happens, optional user info
</member>
        <member name="M:btDynamicsWorld.stepSimulation(System.Single,System.Int32,System.Single)">
stepSimulation proceeds the simulation over 'timeStep', units in preferably in seconds.
By default, Bullet will subdivide the timestep in constant substeps of each 'fixedTimeStep'.
in order to keep the simulation real-time, the maximum number of substeps can be clamped to 'maxSubSteps'.
You can disable subdividing the timestep/substepping by passing maxSubSteps=0 as second argument to stepSimulation, but in that case you have to keep the timeStep constant.
</member>
        <member name="T:btDynamicsWorld">
The btDynamicsWorld is the interface class for several dynamics implementation, basic, discrete, parallel, and continuous etc.
</member>
        <member name="D:btInternalTickCallback">
Type for the callback for each tick
</member>
        <member name="T:btContactSolverInfoFloatData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btContactSolverInfoDoubleData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btIDebugDraw.setDefaultColors(btIDebugDraw.DefaultColors!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
the default implementation for setDefaultColors has no effect. A derived class can implement it and store the colors.
</member>
        <member name="T:btIDebugDraw">
The btIDebugDraw interface class allows hooking up a debug renderer to visually debug simulations.
Typical use case: create a debug drawer object, and assign it to a btCollisionWorld or btDynamicsWorld using setDebugDrawer and call debugDrawWorld.
A class that implements the btIDebugDraw interface has to implement the drawLine method at a minimum.
For color arguments the X,Y,Z components refer to Red, Green and Blue each in the range [0..1]

solve a group of constraints
</member>
        <member name="T:CProfileSample">
ProfileSampleClass is a simple way to profile a function's scope
Use the BT_PROFILE macro at the start of scope to time
</member>
        <member name="T:CProfileManager">
The Manager for the Profile system
</member>
        <member name="T:CProfileIterator">
An iterator to navigate through the tree
</member>
        <member name="T:CProfileNode">
A node in the Profile Hierarchy Tree
</member>
        <member name="M:btClock.getTimeSeconds">
Returns the time in s since the last call to reset or since 
the Clock was created.
</member>
        <member name="M:btClock.getTimeMicroseconds">
Returns the time in us since the last call to reset or since 
the Clock was created.
</member>
        <member name="M:btClock.getTimeMilliseconds">
Returns the time in ms since the last call to reset or since 
the btClock was created.
</member>
        <member name="M:btClock.reset">
Resets the initial reference time.
</member>
        <member name="T:btClock">
The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
</member>
        <member name="M:btDefaultMotionState.setWorldTransform(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
synchronizes world transform from physics to user
Bullet only calls the update of worldtransform for active objects
</member>
        <member name="M:btDefaultMotionState.getWorldTransform(btTransform*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
synchronizes world transform from user to physics
</member>
        <member name="T:bt32BitAxisSweep3">
The bt32BitAxisSweep3 allows higher precision quantization and more objects compared to the btAxisSweep3 sweep and prune.
This comes at the cost of more memory per handle, and a bit slower performance.
It uses arrays rather then lists for storage of the 3 axis.
</member>
        <member name="T:btAxisSweep3">
The btAxisSweep3 is an efficient implementation of the 3d axis sweep and prune broadphase.
It uses arrays rather then lists for storage of the 3 axis. Also it operates using 16 bit integer coordinates instead of floats.
For large worlds and many objects, use bt32BitAxisSweep3 or btDbvtBroadphase instead. bt32BitAxisSweep3 has higher precision and allows more then 16384 objects at the cost of more memory and bit of performance.
</member>
        <member name="M:btDbvtBroadphase.setAabbForceUpdate(btBroadphaseProxy*,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btDispatcher*)">
this setAabbForceUpdate is similar to setAabb but always forces the aabb update. 
it is not part of the btBroadphaseInterface but specific to btDbvtBroadphase.
it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
http://code.google.com/p/bullet/issues/detail?id=223
</member>
        <member name="M:btDbvtBroadphase.resetPool(btDispatcher*)">
reset broadphase internal structures, to ensure determinism/reproducability
</member>
        <member name="T:btDbvtBroadphase">
The btDbvtBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see btDbvt).
One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases btAxisSweep3 and bt32BitAxisSweep3.
</member>
        <member name="T:btDbvt">
The btDbvt class implements a fast dynamic bounding volume tree based on axis aligned bounding boxes (aabb tree).
This btDbvt is used for soft body collision detection and for the btDbvtBroadphase. It has a fast insert, remove and update of nodes.
Unlike the btQuantizedBvh, nodes can be dynamically moved around, which allows for change in topology of the underlying data structure.
</member>
        <member name="T:btDbvtAabbMm">
btDbvtBroadphase implementation by Nathanael Presson
btDbvt implementation by Nathanael Presson
</member>
        <member name="M:btSimpleBroadphase.getBroadphaseAabb(btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
getAabb returns the axis aligned bounding box in the 'global' coordinate frame
will add some transform later
</member>
        <member name="M:btSimpleBroadphase.resetPool(btDispatcher*)">
reset broadphase internal structures, to ensure determinism/reproducability
</member>
        <member name="T:btSimpleBroadphase">
The SimpleBroadphase is just a unit-test for btAxisSweep3, bt32BitAxisSweep3, or btDbvtBroadphase, so use those classes instead.
It is a brute force aabb culling broadphase based on O(n^2) aabb checks
</member>
        <member name="T:btSimpleBroadphaseProxy">
Dispatching and generation of collision pairs (broadphase)
</member>
        <member name="M:btDefaultCollisionConfiguration.setConvexConvexMultipointIterations(System.Int32,System.Int32)">
Use this method to allow to generate multiple contact points between at once, between two objects using the generic convex-convex algorithm.
By default, this feature is disabled for best performance.
@param numPerturbationIterations controls the number of collision queries. Set it to zero to disable the feature.
@param minimumPointsPerturbationThreshold is the minimum number of points in the contact cache, above which the feature is disabled
3 is a good value for both params, if you want to enable the feature. This is because the default contact cache contains a maximum of 4 points, and one collision query at the unperturbed orientation is performed first.
See Bullet/Demos/CollisionDemo for an example how this feature gathers multiple points.
@todo we could add a per-object setting of those parameters, for level-of-detail collision detection.
</member>
        <member name="M:btDefaultCollisionConfiguration.getPersistentManifoldPool">
memory pools
</member>
        <member name="T:btDefaultCollisionConfiguration">
btCollisionConfiguration allows to configure Bullet collision detection
stack allocator, pool memory allocators
@todo: describe the meaning
</member>
        <member name="M:btCollisionConfiguration.getPersistentManifoldPool">
memory pools
</member>
        <member name="T:btCollisionConfiguration">
btCollisionConfiguration allows to configure Bullet collision detection
stack allocator size, default collision algorithms and persistent manifold pool size
@todo: describe the meaning
</member>
        <member name="T:btSphereSphereCollisionAlgorithm">
btSphereSphereCollisionAlgorithm  provides sphere-sphere collision detection.
Other features are frame-coherency (persistent data) and collision response.
Also provides the most basic sample for custom/user btCollisionAlgorithm
</member>
        <member name="T:btActivatingCollisionAlgorithm">
This class is not enabled yet (work-in-progress) to more aggressively activate objects.
</member>
        <member name="T:btCollisionAlgorithm">
btCollisionAlgorithm is an collision interface that is compatible with the Broadphase and btDispatcher.
It is persistent over frames
</member>
        <member name="M:btUniformScalingShape.getAabb(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
</member>
        <member name="T:btUniformScalingShape">
The btUniformScalingShape allows to re-use uniform scaled instances of btConvexShape in a memory efficient way.
Istead of using btUniformScalingShape, it is better to use the non-uniform setLocalScaling method on convex shapes that implement it.
</member>
        <member name="M:btMultiSphereShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btMultiSphereShape.localGetSupportingVertexWithoutMargin(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
btConvexShape Interface
</member>
        <member name="M:btMultiSphereShape.calculateLocalInertia(System.Single,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
CollisionShape Interface
</member>
        <member name="T:btMultiSphereShape">
The btMultiSphereShape represents the convex hull of a collection of spheres. You can create special capsules or other smooth volumes.
It is possible to animate the spheres for deformation, but call 'recalcLocalAabb' after changing any sphere position/radius
</member>
        <member name="M:btEmptyShape.getAabb(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
</member>
        <member name="T:btEmptyShape">
The btEmptyShape is a collision shape without actual collision detection shape, so most users should ignore this class.
It can be replaced by another shape during runtime, but the inertia tensor should be recomputed.
</member>
        <member name="M:btBU_Simplex1to4.getName">
getName is for debugging
</member>
        <member name="T:btBU_Simplex1to4">
The btBU_Simplex1to4 implements tetrahedron, triangle, line, vertex collision shapes. In most cases it is better to use btConvexHullShape instead.
</member>
        <member name="T:btCompoundShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btCompoundShapeChildData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btCompoundShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btCompoundShape.calculatePrincipalAxisTransform(System.Single*,btTransform*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
and the center of mass to the current coordinate system. "masses" points to an array of masses of the children. The resulting transform
"principal" has to be applied inversely to all children transforms in order for the local coordinate system of the compound
shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
of the collision object by the principal transform.
</member>
        <member name="M:btCompoundShape.recalculateLocalAabb">
Re-calculate the local Aabb. Is called at the end of removeChildShapes. 
	Use this yourself if you modify the children or their transforms. 
</member>
        <member name="M:btCompoundShape.getAabb(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
</member>
        <member name="M:btCompoundShape.updateChildTransform(System.Int32,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
set a new transform for a child, and update internal data structures (local aabb and dynamic tree)
</member>
        <member name="M:btCompoundShape.removeChildShape(btCollisionShape*)">
Remove all children shapes that contain the specified shape
</member>
        <member name="F:btCompoundShape.m_updateRevision">
increment m_updateRevision when adding/removing/replacing child shapes, so that some caches can be updated
</member>
        <member name="T:btCompoundShape">
The btCompoundShape allows to store multiple other btCollisionShapes
This allows for moving concave collision objects. This is more general then the static concave btBvhTriangleMeshShape.
It has an (optional) dynamic aabb tree to accelerate early rejection tests. 
@todo: This aabb tree can also be use to speed up ray tests on btCompoundShape, see http://code.google.com/p/bullet/issues/detail?id=25
Currently, removal of child shapes is only supported when disabling the aabb tree (pass 'false' in the constructor of btCompoundShape)
</member>
        <member name="T:btScaledTriangleMeshShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btScaledBvhTriangleMeshShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="T:btScaledBvhTriangleMeshShape">
The btScaledBvhTriangleMeshShape allows to instance a scaled version of an existing btBvhTriangleMeshShape.
Note that each btBvhTriangleMeshShape still can have its own local scaling, independent from this btScaledBvhTriangleMeshShape 'localScaling'
</member>
        <member name="T:btTriangleMeshShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btBvhTriangleMeshShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btBvhTriangleMeshShape.partialRefitTree(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
for a fast incremental refit of parts of the tree. Note: the entire AABB of the tree will become more conservative, it never shrinks
</member>
        <member name="M:btBvhTriangleMeshShape.#ctor(btStridingMeshInterface*,System.Boolean,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
optionally pass in a larger bvh aabb, used for quantization. This allows for deformations within this aabb
</member>
        <member name="T:btBvhTriangleMeshShape">
The btBvhTriangleMeshShape is a static-triangle mesh shape, it can only be used for fixed/non-moving objects.
If you required moving concave triangle meshes, it is recommended to perform convex decomposition
using HACD, see Bullet/Demos/ConvexDecompositionDemo. 
Alternatively, you can use btGimpactMeshShape for moving concave triangle meshes.
btBvhTriangleMeshShape has several optimizations, such as bounding volume hierarchy and 
cache friendly traversal for PlayStation 3 Cell SPU. 
It is recommended to enable useQuantizedAabbCompression for better memory usage.
It takes a triangle mesh as input, for example a btTriangleMesh or btTriangleIndexVertexArray. The btBvhTriangleMeshShape class allows for triangle mesh deformations by a refit or partialRefit method.
Instead of building the bounding volume hierarchy acceleration structure, it is also possible to serialize (save) and deserialize (load) the structure from disk.
See Demos\ConcaveDemo\ConcavePhysicsDemo.cpp for an example.
</member>
        <member name="M:btTriangleInfoMap.deSerialize(btTriangleInfoMapData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="T:btTriangleInfoData">
those fields have to be float and not btScalar for the serialization to work properly
</member>
        <member name="M:btTriangleInfoMap.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="T:btTriangleInfoMap">
The btTriangleInfoMap stores edge angle information for some triangles. You can compute this information yourself or using btGenerateInternalEdgeInfo.
</member>
        <member name="T:btTriangleInfo">
In general it is best to use btDefaultSerializer,
in particular when writing the data to disk or sending it over the network.
The btInMemorySerializer is experimental and only suitable in a few cases.
The btInMemorySerializer takes a shortcut and can be useful to create a deep-copy
of objects. There will be a demo on how to use the btInMemorySerializer.
for btTriangleInfo m_flags
The btTriangleInfo structure stores information to adjust collision normals to avoid collisions against internal edges
it can be generated using 
</member>
        <member name="T:btDefaultSerializer">
The btDefaultSerializer is the main Bullet serialization class.
The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
</member>
        <member name="F:sBulletDNAstr">
only the 32bit versions for now
</member>
        <member name="T:btHashString">
very basic hashable string implementation, compatible with btHashMap
</member>
        <member name="M:btOptimizedBvh.deSerializeInPlace(System.Void*,System.UInt32,System.Boolean)">
deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
</member>
        <member name="M:btOptimizedBvh.serializeInPlace(System.Void*,System.UInt32,System.Boolean)">
Data buffer MUST be 16 byte aligned
</member>
        <member name="T:btOptimizedBvh">
The btOptimizedBvh extends the btQuantizedBvh to create AABB tree for triangle meshes, through the btStridingMeshInterface.
</member>
        <member name="M:btQuantizedBvh.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btQuantizedBvh.deSerializeInPlace(System.Void*,System.UInt32,System.Boolean)">
deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
</member>
        <member name="M:btQuantizedBvh.serialize(System.Void*,System.UInt32,System.Boolean)">
Data buffer MUST be 16 byte aligned
</member>
        <member name="M:btQuantizedBvh.setTraversalMode(btQuantizedBvh.btTraversalMode)">
setTraversalMode let's you choose between stackless, recursive or stackless cache friendly tree traversal. Note this is only implemented for quantized trees.
</member>
        <member name="M:btQuantizedBvh.reportAabbOverlappingNodex(btNodeOverlapCallback*,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
***************************************** expert/internal use only *************************
</member>
        <member name="M:btQuantizedBvh.buildInternal">
buildInternal is expert use only: assumes that setQuantizationValues and LeafNodeArray are initialized
</member>
        <member name="M:btQuantizedBvh.setQuantizationValues(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
***************************************** expert/internal use only *************************
</member>
        <member name="M:btQuantizedBvh.walkRecursiveQuantizedTreeAgainstQuantizedTree(btQuantizedBvhNode!System.Runtime.CompilerServices.IsConst*,btQuantizedBvhNode!System.Runtime.CompilerServices.IsConst*,btNodeOverlapCallback*)">
use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
</member>
        <member name="M:btQuantizedBvh.walkRecursiveQuantizedTreeAgainstQueryAabb(btQuantizedBvhNode!System.Runtime.CompilerServices.IsConst*,btNodeOverlapCallback*,System.UInt16*,System.UInt16*)">
use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
</member>
        <member name="M:btQuantizedBvh.walkStacklessQuantizedTreeCacheFriendly(btNodeOverlapCallback*,System.UInt16*,System.UInt16*)">
tree traversal designed for small-memory processors like PS3 SPU
</member>
        <member name="M:btQuantizedBvh.setInternalNodeAabbMin(System.Int32,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
two versions, one for quantized and normal nodes. This allows code-reuse while maintaining readability (no template/macro!)
this might be refactored into a virtual, it is usually not calculated at run-time
</member>
        <member name="T:btQuantizedBvh">
The btQuantizedBvh class stores an AABB tree that can be quickly traversed on CPU and Cell SPU.
It is used by the btBvhTriangleMeshShape as midphase.
It is recommended to use quantization for better performance and lower memory requirements.
</member>
        <member name="D:NodeArray">
for code readability:
</member>
        <member name="T:btBvhSubtreeInfo">
btBvhSubtreeInfo provides info to gather a subtree of limited size
</member>
        <member name="T:btOptimizedBvhNode">
btOptimizedBvhNode contains both internal and leaf node information.
Total node size is 44 bytes / node. You can use the compressed version of 16 bytes.
</member>
        <member name="T:btQuantizedBvhNode">
btQuantizedBvhNode is a compressed aabb node, 16 bytes.
Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
</member>
        <member name="M:btTriangleMeshShape.#ctor(btStridingMeshInterface*)">
btTriangleMeshShape constructor has been disabled/protected, so that users will not mistakenly use this class.
Don't use btTriangleMeshShape but use btBvhTriangleMeshShape instead!
</member>
        <member name="T:btTriangleMeshShape">
The btTriangleMeshShape is an internal concave triangle mesh interface. Don't use this class directly, use btBvhTriangleMeshShape instead.
</member>
        <member name="M:btConvexTriangleMeshShape.calculatePrincipalAxisTransform(btTransform*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
and the center of mass to the current coordinate system. A mass of 1 is assumed, for other masses just multiply the computed "inertia"
by the mass. The resulting transform "principal" has to be applied inversely to the mesh in order for the local coordinate system of the
shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
of the collision object by the principal transform. This method also computes the volume of the convex mesh.
</member>
        <member name="T:btConvexTriangleMeshShape">
The btConvexTriangleMeshShape is a convex hull of a triangle mesh, but the performance is not as good as btConvexHullShape.
A small benefit of this class is that it uses the btStridingMeshInterface, so you can avoid the duplication of the triangle mesh data. Nevertheless, most users should use the much better performing btConvexHullShape instead.
</member>
        <member name="M:btTriangleMesh.addIndex(System.Int32)">
addIndex is an internal method, use addTriangle instead
</member>
        <member name="M:btTriangleMesh.findOrAddVertex(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
findOrAddVertex is an internal method, use addTriangle instead
</member>
        <member name="M:btTriangleMesh.addTriangleIndices(System.Int32,System.Int32,System.Int32)">
Add a triangle using its indices. Make sure the indices are pointing within the vertices array, so add the vertices first (and to be sure, avoid removal of duplicate vertices)	
</member>
        <member name="M:btTriangleMesh.addTriangle(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
By default addTriangle won't search for duplicate vertices, because the search is very slow for large triangle meshes.
In general it is better to directly use btTriangleIndexVertexArray instead.
</member>
        <member name="T:btTriangleMesh">
The btTriangleMesh class is a convenience class derived from btTriangleIndexVertexArray, that provides storage for a concave triangle mesh. It can be used as data for the btBvhTriangleMeshShape.
It allows either 32bit or 16bit indices, and 4 (x-y-z-w) or 3 (x-y-z) component vertices.
If you want to share triangle/index data between graphics mesh and collision mesh (btBvhTriangleMeshShape), you can directly use btTriangleIndexVertexArray or derive your own class from btStridingMeshInterface.
Performance of btTriangleMesh and btTriangleIndexVertexArray used in a btBvhTriangleMeshShape is the same.
</member>
        <member name="M:btTriangleIndexVertexArray.getNumSubParts">
getNumSubParts returns the number of seperate subparts
each subpart has a continuous array of vertices and indices
</member>
        <member name="M:btTriangleIndexVertexArray.unLockVertexBase(System.Int32)">
unLockVertexBase finishes the access to a subpart of the triangle mesh
make a call to unLockVertexBase when the read and write access (using getLockedVertexIndexBase) is finished
</member>
        <member name="T:btTriangleIndexVertexArray">
The btTriangleIndexVertexArray allows to access multiple triangle meshes, by indexing into existing triangle/index arrays.
Additional meshes can be added using addIndexedMesh
No duplcate is made of the vertex/index data, it only indexes into external vertex/index arrays.
So keep those arrays around during the lifetime of this btTriangleIndexVertexArray.
</member>
        <member name="T:btIndexedMesh">
The btIndexedMesh indexes a single vertex and index array. Multiple btIndexedMesh objects can be passed into a btTriangleIndexVertexArray using addIndexedMesh.
Instead of the number of indices, we pass the number of triangles.
</member>
        <member name="T:btStridingMeshInterfaceData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btMeshPartData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btStridingMeshInterface.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btStridingMeshInterface.getNumSubParts">
getNumSubParts returns the number of seperate subparts
each subpart has a continuous array of vertices and indices
</member>
        <member name="M:btStridingMeshInterface.unLockVertexBase(System.Int32)">
unLockVertexBase finishes the access to a subpart of the triangle mesh
make a call to unLockVertexBase when the read and write access (using getLockedVertexIndexBase) is finished
</member>
        <member name="M:btStridingMeshInterface.getLockedVertexIndexBase(System.Byte**,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PHY_ScalarType*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte**,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PHY_ScalarType*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
get read and write access to a subpart of a triangle mesh
this subpart has a continuous array of vertices and indices
in this way the mesh can be handled as chunks of memory with striding
very similar to OpenGL vertexarray support
make a call to unLockVertexBase when the read and write access is finished	
</member>
        <member name="M:btStridingMeshInterface.calculateAabbBruteForce(btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
brute force method to calculate aabb
</member>
        <member name="T:btStridingMeshInterface">
The btStridingMeshInterface is the interface class for high performance generic access to triangle meshes, used in combination with btBvhTriangleMeshShape and some other collision shapes.
Using index striding of 3*sizeof(integer) it can use triangle arrays, using index striding of 1*sizeof(integer) it can handle triangle strips.
It allows for sharing graphics and collision meshes. Also it provides locking/unlocking of graphics meshes that are in gpu memory.
</member>
        <member name="T:btConvexHullShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btConvexHullShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btConvexHullShape.setLocalScaling(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
in case we receive negative scaling
</member>
        <member name="M:btConvexHullShape.getPoints">
getPoints is obsolete, please use getUnscaledPoints
</member>
        <member name="M:btConvexHullShape.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
this constructor optionally takes in a pointer to points. Each point is assumed to be 3 consecutive btScalar (x,y,z), the striding defines the number of bytes between each point, in memory.
It is easier to not pass any points in the constructor, and just add one point at a time, using addPoint.
btConvexHullShape make an internal copy of the points.
</member>
        <member name="T:btConvexHullShape">
The btConvexHullShape implements an implicit convex hull of an array of vertices.
Bullet provides a general and fast collision detector for convex shapes based on GJK and EPA using localGetSupportingVertex.
</member>
        <member name="T:btStaticPlaneShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btStaticPlaneShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="T:btStaticPlaneShape">
The btStaticPlaneShape simulates an infinite non-moving (static) collision plane.
</member>
        <member name="T:btConcaveShape">
The btConcaveShape class provides an interface for non-moving (static) concave shapes.
It has been implemented by the btStaticPlaneShape, btBvhTriangleMeshShape and btHeightfieldTerrainShape.
</member>
        <member name="T:PHY_ScalarType">
PHY_ScalarType enumerates possible scalar types.
See the btStridingMeshInterface or btHeightfieldTerrainShape for its use
</member>
        <member name="T:btTriangleCallback">
The btTriangleCallback provides a callback for each overlapping triangle when calling processAllTriangles.
This callback is called by processAllTriangles for all btConcaveShape derived class, such as  btBvhTriangleMeshShape, btStaticPlaneShape and btHeightfieldTerrainShape.
</member>
        <member name="T:btConeShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btConeShapeZ">
btConeShapeZ implements a Cone shape, around the Z axis
</member>
        <member name="T:btConeShapeX">
btConeShape implements a Cone shape, around the X axis
</member>
        <member name="M:btConeShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btConeShape.setConeUpIndex(System.Int32)">
choose upAxis index
</member>
        <member name="T:btConeShape">
The btConeShape implements a cone shape primitive, centered around the origin and aligned with the Y axis. The btConeShapeX is aligned around the X axis and btConeShapeZ around the Z axis.
</member>
        <member name="T:btCylinderShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btCylinderShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="T:btCylinderShape">
The btCylinderShape class implements a cylinder shape primitive, centered around the origin. Its central axis aligned with the Y axis. btCylinderShapeX is aligned with the X axis and btCylinderShapeZ around the Z axis.
</member>
        <member name="T:btCapsuleShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btCapsuleShapeZ">
btCapsuleShapeZ represents a capsule around the Z axis
the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
</member>
        <member name="T:btCapsuleShapeX">
btCapsuleShapeX represents a capsule around the Z axis
the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
</member>
        <member name="M:btCapsuleShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btCapsuleShape.localGetSupportingVertexWithoutMargin(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
btConvexShape Interface
</member>
        <member name="M:btCapsuleShape.calculateLocalInertia(System.Single,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
CollisionShape Interface
</member>
        <member name="M:btCapsuleShape.#ctor">
only used for btCapsuleShapeZ and btCapsuleShapeX subclasses.
</member>
        <member name="T:btCapsuleShape">
The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres.
</member>
        <member name="T:btSphereShape">
The btSphereShape implements an implicit sphere, centered around a local origin with radius.
</member>
        <member name="T:btBoxShape">
The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
</member>
        <member name="T:btPolyhedralConvexAabbCachingShape">
The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape
</member>
        <member name="M:btPolyhedralConvexShape.initializePolyhedralFeatures(System.Int32)">
optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
experimental/work-in-progress
</member>
        <member name="T:btPolyhedralConvexShape">
The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes.
</member>
        <member name="T:btConvexInternalAabbCachingShape">
btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations
</member>
        <member name="T:btConvexInternalShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btConvexInternalShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btConvexInternalShape.getAabb(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
</member>
        <member name="M:btConvexInternalShape.setImplicitShapeDimensions(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
warning: use setImplicitShapeDimensions with care
changing a collision shape while the body is in the world is not recommended,
it is best to remove the body from the world, then make the change, and re-add it
alternatively flush the contact points, see documentation for 'cleanProxyFromPairs'
</member>
        <member name="T:btConvexInternalShape">
The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
Note that when creating small shapes (derived from btConvexInternalShape), 
you need to make sure to set a smaller collision margin, using the 'setMargin' API
There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape
</member>
        <member name="M:TestTriangleAgainstAabb2(btVector3!System.Runtime.CompilerServices.IsConst*,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conservative test for overlap between triangle and aabb
</member>
        <member name="M:TestAabbAgainstAabb2(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conservative test for overlap between two aabbs
</member>
        <member name="M:TestPointAgainstAabb2(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conservative test for overlap between two aabbs
</member>
        <member name="M:btConvexShape.getAabb(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
</member>
        <member name="T:btConvexShape">
The CONVEX_DISTANCE_MARGIN is a default collision margin for convex collision shapes derived from btConvexInternalShape.
This collision margin is used by Gjk and some other algorithms
Note that when creating small objects, you need to make sure to set a smaller collision margin, using the 'setMargin' API
The btConvexShape is an abstract shape interface, implemented by all convex shapes such as btBoxShape, btConvexHullShape etc.
It describes general convex shapes using the localGetSupportingVertex interface, used by collision detectors such as btGjkPairDetector.
</member>
        <member name="T:btCollisionShapeData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="M:btCollisionShape.serialize(System.Void*,btSerializer*)">
fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btCollisionShape.setUserPointer(System.Void*)">
optional user data pointer
</member>
        <member name="M:btCollisionShape.getAnisotropicRollingFrictionDirection">
the getAnisotropicRollingFrictionDirection can be used in combination with setAnisotropicFriction
See Bullet/Demos/RollingFrictionDemo for an example
</member>
        <member name="M:btCollisionShape.isInfinite">
isInfinite is used to catch simulation error (aabb check)
</member>
        <member name="M:btCollisionShape.calculateTemporalAabb(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
result is conservative
</member>
        <member name="M:btCollisionShape.getAngularMotionDisc">
getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations.
</member>
        <member name="M:btCollisionShape.getAabb(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
getAabb returns the axis aligned bounding box in the coordinate frame of the given transform t.
</member>
        <member name="M:btCollisionWorld.serialize(btSerializer*)">
Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (Bullet/Demos/SerializeDemo)
</member>
        <member name="M:btCollisionWorld.objectQuerySingle(btConvexShape!System.Runtime.CompilerServices.IsConst*,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btCollisionObject*,btCollisionShape!System.Runtime.CompilerServices.IsConst*,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btCollisionWorld.ConvexResultCallback*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
objectQuerySingle performs a collision detection query and calls the resultCallback. It is used internally by rayTest.
</member>
        <member name="M:btCollisionWorld.rayTestSingle(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btCollisionObject*,btCollisionShape!System.Runtime.CompilerServices.IsConst*,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btCollisionWorld.RayResultCallback*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
This allows more customization.
</member>
        <member name="M:btCollisionWorld.contactPairTest(btCollisionObject*,btCollisionObject*,btCollisionWorld.ContactResultCallback*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
it reports one or more contact points (including the one with deepest penetration)
</member>
        <member name="M:btCollisionWorld.contactTest(btCollisionObject*,btCollisionWorld.ContactResultCallback*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
contactTest performs a discrete collision test between colObj against all objects in the btCollisionWorld, and calls the resultCallback.
it reports one or more contact points for every overlapping object (including the one with deepest penetration)
</member>
        <member name="M:btCollisionWorld.convexSweepTest(btConvexShape!System.Runtime.CompilerServices.IsConst*,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btCollisionWorld.ConvexResultCallback*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
convexTest performs a swept convex cast on all objects in the btCollisionWorld, and calls the resultCallback
This allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback.
</member>
        <member name="M:btCollisionWorld.rayTest(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btCollisionWorld.RayResultCallback*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
rayTest performs a raycast on all objects in the btCollisionWorld, and calls the resultCallback
This allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback.
</member>
        <member name="T:btCollisionWorld.ContactResultCallback">
ContactResultCallback is used to report contact points
</member>
        <member name="T:btCollisionWorld.ConvexResultCallback">
RayResultCallback is used to report new raycast results
</member>
        <member name="T:btCollisionWorld.RayResultCallback">
RayResultCallback is used to report new raycast results
</member>
        <member name="T:btCollisionWorld.LocalShapeInfo">
LocalShapeInfo gives extra information for complex shapes
Currently, only btTriangleMeshShape is available, so it just contains triangleIndex and subpart
</member>
        <member name="M:btCollisionWorld.computeOverlappingPairs">
the computeOverlappingPairs is usually already called by performDiscreteCollisionDetection (or stepSimulation)
it can be useful to use if you perform ray tests without collision detection/simulation
</member>
        <member name="F:btCollisionWorld.m_forceUpdateAllAabbs">
m_forceUpdateAllAabbs can be set to false as an optimization to only update active object AABBs
it is true by default, because it is error-prone (setting the position of static objects wouldn't update their AABB)
</member>
        <member name="T:btCollisionWorld">
CollisionWorld is interface and container for the collision detection
</member>
        <member name="T:btNullPairCache">
btNullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
</member>
        <member name="F:btSortedOverlappingPairCache.m_hasDeferredRemoval">
by default, do the removal during the pair traversal
</member>
        <member name="T:btSortedOverlappingPairCache">
btSortedOverlappingPairCache maintains the objects with overlapping AABB
Typically managed by the Broadphase, Axis3Sweep or btSimpleBroadphase
</member>
        <member name="T:btHashedOverlappingPairCache">
Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com
</member>
        <member name="T:btOverlappingPairCache">
The btOverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the btBroadphaseInterface broadphases.
The btHashedOverlappingPairCache and btSortedOverlappingPairCache classes are two implementations.
</member>
        <member name="T:btOverlappingPairCallback">
The btOverlappingPairCallback class is an additional optional broadphase user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
</member>
        <member name="M:btBroadphaseInterface.resetPool(btDispatcher*)">
reset broadphase internal structures, to ensure determinism/reproducability
</member>
        <member name="M:btBroadphaseInterface.getBroadphaseAabb(btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
getAabb returns the axis aligned bounding box in the 'global' coordinate frame
will add some transform later
</member>
        <member name="M:btBroadphaseInterface.calculateOverlappingPairs(btDispatcher*)">
calculateOverlappingPairs is optional: incremental algorithms (sweep and prune) might do it during the set aabb
</member>
        <member name="T:btBroadphaseInterface">
The btBroadphaseInterface class provides an interface to detect aabb-overlapping object pairs.
Some implementations for this broadphase interface include btAxisSweep3, bt32BitAxisSweep3 and btDbvtBroadphase.
The actual overlapping pair management, storage, adding and removing of pairs is dealt by the btOverlappingPairCache class.
</member>
        <member name="F:btBroadphaseRayCallback.m_rayDirectionInverse">
added some cached data to accelerate ray-AABB tests
</member>
        <member name="M:btCollisionDispatcher.registerCollisionCreateFunc(System.Int32,System.Int32,btCollisionAlgorithmCreateFunc*)">
registerCollisionCreateFunc allows registration of custom/alternative collision create functions
</member>
        <member name="T:btCollisionDispatcher">
btCollisionDispatcher supports algorithms that handle ConvexConvex and ConvexConcave collision pairs.
Time of Impact, Closest Points and Penetration Depth.
</member>
        <member name="D:btNearCallback">
user can override this nearcallback for collision filtering and more finegrained control over collision detection
</member>
        <member name="T:btCollisionAlgorithmCreateFunc">
Used by the btCollisionDispatcher to register and create instances for btCollisionAlgorithm
</member>
        <member name="T:btBroadphasePair">
The btBroadphasePair class contains a pair of aabb-overlapping objects.
A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
</member>
        <member name="T:btBroadphaseProxy.CollisionFilterGroups">
optional filtering to cull potential collisions
</member>
        <member name="T:btBroadphaseProxy">
The btBroadphaseProxy is the main class that can be used with the Bullet broadphases. 
It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.

Narrowphase Collision Detector
</member>
        <member name="T:BroadphaseNativeTypes">
btDispatcher uses these types
IMPORTANT NOTE:The types are ordered polyhedral, implicit convex and concave
to facilitate type checking
CUSTOM_POLYHEDRAL_SHAPE_TYPE,CUSTOM_CONVEX_SHAPE_TYPE and CUSTOM_CONCAVE_SHAPE_TYPE can be used to extend Bullet without modifying source code
</member>
        <member name="F:MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE">
Multimaterial mesh
</member>
        <member name="F:GIMPACT_SHAPE_PROXYTYPE">
Used for GIMPACT Trimesh integration
</member>
        <member name="F:FAST_CONCAVE_MESH_PROXYTYPE">
used for demo integration FAST/Swift collision library and Bullet
</member>
        <member name="M:btManifoldResult.calculateCombinedRestitution(btCollisionObject!System.Runtime.CompilerServices.IsConst*,btCollisionObject!System.Runtime.CompilerServices.IsConst*)">
in the future we can let the user override the methods to combine restitution and friction
</member>
        <member name="T:btManifoldResult">
btManifoldResult is a helper class to manage  contact results.
</member>
        <member name="M:btDiscreteCollisionDetectorInterface.Result.setShapeIdentifiersA(System.Int32,System.Int32)">
setShapeIdentifiersA/B provides experimental support for per-triangle material / custom material combiner
</member>
        <member name="T:btDiscreteCollisionDetectorInterface">
This interface is made to be used by an iterative approach to do TimeOfImpact calculations
This interface allows to query for closest points and penetration depth between two (convex) objects
the closest point is on the second object (B), and the normal points from the surface on B towards A.
distance is between closest points on B and closest point on A. So you can calculate closest point on A
by taking closestPointInA = closestPointInB + m_distance * m_normalOnSurfaceB
</member>
        <member name="M:btPersistentManifold.refreshContactPoints(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculated new worldspace coordinates and depth, and reject points that exceed the collision margin
</member>
        <member name="M:btPersistentManifold.getContactBreakingThreshold">
@todo: get this margin from the current physics / collision environment
</member>
        <member name="M:btPersistentManifold.setNumContacts(System.Int32)">
the setNumContacts API is usually not used, except when you gather/fill all contacts manually
</member>
        <member name="M:btPersistentManifold.sortCachedPoints(btManifoldPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
sort cached points so most isolated points come first
</member>
        <member name="F:btPersistentManifold.m_body0">
this two body pointers can point to the physics rigidbody class.
</member>
        <member name="T:btPersistentManifold">
btPersistentManifold is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
Those contact points are created by the collision narrow phase.
The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
reduces the cache to 4 points, when more then 4 points are added, using following rules:
the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
note that some pairs of objects might have more then one contact manifold.
</member>
        <member name="F:gContactBreakingThreshold">
maximum contact breaking and merging threshold
</member>
        <member name="M:btManifoldPoint.getAppliedImpulse">
this returns the most recent applied impulse, to satisfy contact constraints by the constraint solver
</member>
        <member name="F:btManifoldPoint.m_positionWorldOnA">
m_positionWorldOnA is redundant information, see getPositionWorldOnA(), but for clarity
</member>
        <member name="T:btManifoldPoint">
ManifoldContactPoint collects and maintains persistent contactpoints.
used to improve stability and performance of rigidbody dynamics response.
</member>
        <member name="T:btConvexSeparatingDistanceUtil">
The btConvexSeparatingDistanceUtil can help speed up convex collision detection 
by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
</member>
        <member name="T:btTransformUtil">
Utils related to temporal transforms
</member>
        <member name="T:btDispatcher">
The btDispatcher interface class can be used in combination with broadphase to dispatch calculations for overlapping pairs.
For example for pairwise collision detection, calculating contact points stored in btPersistentManifold or user callbacks (game logic).
</member>
        <member name="T:btCollisionObjectFloatData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btCollisionObjectDoubleData">
do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
</member>
        <member name="T:btSerializer">
fills the dataBuffer and returns the struct name (and 0 on failure)

Collision Shapes

Contains contributions from Disney Studio's

fills the dataBuffer and returns the struct name (and 0 on failure)
</member>
        <member name="M:btCollisionObject.setUserIndex(System.Int32)">
users can point to their objects, userPointer is not used by Bullet
</member>
        <member name="M:btCollisionObject.setUserPointer(System.Void*)">
users can point to their objects, userPointer is not used by Bullet
</member>
        <member name="M:btCollisionObject.getUserPointer">
users can point to their objects, userPointer is not used by Bullet
</member>
        <member name="M:btCollisionObject.setCcdMotionThreshold(System.Single)">
Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
</member>
        <member name="M:btCollisionObject.setCcdSweptSphereRadius(System.Single)">
Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
</member>
        <member name="M:btCollisionObject.getCcdSweptSphereRadius">
Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
</member>
        <member name="M:btCollisionObject.getInternalType">
reserved for Bullet internal usage
</member>
        <member name="M:btCollisionObject.internalSetExtensionPointer(System.Void*)">
Avoid using this internal API call, the extension pointer is used by some Bullet extensions
If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
</member>
        <member name="M:btCollisionObject.internalGetExtensionPointer">
Avoid using this internal API call, the extension pointer is used by some Bullet extensions. 
If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
</member>
        <member name="M:btCollisionObject.setContactProcessingThreshold(System.Single)">
the constraint solver can discard solving contacts, if the distance is above this threshold. 0 by default.
Note that using contacts with positive distance can improve stability. It increases, however, the chance of colliding with degerate contacts, such as 'interior' triangle edges
</member>
        <member name="F:CO_GHOST_OBJECT">
CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
It is useful for collision sensors, explosion objects, character controller etc.
</member>
        <member name="F:btCollisionObject.m_updateRevision">
internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
</member>
        <member name="F:btCollisionObject.m_checkCollideWith">
If some object should have elaborate collision filtering by sub-classes
</member>
        <member name="F:btCollisionObject.m_ccdMotionThreshold">
Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
</member>
        <member name="F:btCollisionObject.m_ccdSweptSphereRadius">
Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
</member>
        <member name="F:btCollisionObject.m_hitFraction">
time of impact calculation
</member>
        <member name="F:btCollisionObject.m_userObjectPointer">
users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer
</member>
        <member name="F:btCollisionObject.m_internalType">
m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
do not assign your own m_internalType unless you write a new dynamics object class.
</member>
        <member name="F:btCollisionObject.m_rootCollisionShape">
m_rootCollisionShape is temporarily used to store the original collision shape
The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
If it is NULL, the m_collisionShape is not temporarily replaced.
</member>
        <member name="F:btCollisionObject.m_extensionPointer">
m_extensionPointer is used by some internal low-level Bullet extensions.
</member>
        <member name="F:btCollisionObject.m_interpolationWorldTransform">
m_interpolationWorldTransform is used for CCD and interpolation
it can be either previous or future (predicted) transform
</member>
        <member name="T:btCollisionObject">
btCollisionObject can be used to manage collision detection objects. 
btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
They can be added to the btCollisionWorld.
</member>
        <member name="T:btMotionState">
The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
</member>
        <member name="T:btTransformFloatData">
for serialization
</member>
        <member name="M:op_Equality(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Test if two transforms have all elements equal 
</member>
        <member name="M:btTransform.getIdentity">
@brief Return an identity transform 
</member>
        <member name="M:btTransform.op_Multiply(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the product of this transform and the other 
</member>
        <member name="M:btTransform.inverseTimes(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the inverse of this transform times the other transform
   * @param t The other transform 
   * return this.inverse() * the other 
</member>
        <member name="M:btTransform.inverse">
@brief Return the inverse of this transform 
</member>
        <member name="M:btTransform.op_MultiplicationAssignment(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Multiply this Transform by another(this = this * another) 
   * @param t The other transform 
</member>
        <member name="M:btTransform.setIdentity">
@brief Set this transformation to the identity 
</member>
        <member name="M:btTransform.setRotation(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the rotational element by btQuaternion 
</member>
        <member name="M:btTransform.setBasis(btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the rotational element by btMatrix3x3 
</member>
        <member name="M:btTransform.setOrigin(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the translational element
   * @param origin The vector to set the translation to 
</member>
        <member name="M:btTransform.getOpenGLMatrix(System.Single*)">
@brief Fill an array representation
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation 
</member>
        <member name="M:btTransform.setFromOpenGLMatrix(System.Single!System.Runtime.CompilerServices.IsConst*)">
@brief Set from an array 
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation 
</member>
        <member name="M:btTransform.getRotation">
@brief Return a quaternion representing the rotation 
</member>
        <member name="M:btTransform.getOrigin">
@brief Return the origin vector translation 

@brief Return the origin vector translation 
</member>
        <member name="M:btTransform.getBasis">
@brief Return the basis matrix for the rotation 

@brief Return the basis matrix for the rotation 
</member>
        <member name="M:btTransform.op_Multiply(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the transform of the btQuaternion 
</member>
        <member name="M:btTransform.op_Multiply(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the transform of the vector 
</member>
        <member name="M:btTransform.op_FunctionCall(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the transform of the vector 
</member>
        <member name="M:btTransform.mult(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the current transform as the value of the product of two transforms
   * @param t1 Transform 1
   * @param t2 Transform 2
   * This = Transform1 * Transform2 
</member>
        <member name="M:btTransform.op_Assign(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Assignment Operator 
</member>
        <member name="M:btTransform.#ctor(btTransform!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Copy constructor 
</member>
        <member name="M:btTransform.#ctor(btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Constructor from btMatrix3x3 (optional btVector3)
   * @param b Rotation from Matrix 
   * @param c Translation from Vector default (0,0,0)
</member>
        <member name="M:btTransform.#ctor(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Constructor from btQuaternion (optional btVector3 )
   * @param q Rotation from quaternion 
   * @param c Translation from Vector (default 0,0,0) 
</member>
        <member name="M:btTransform.#ctor">
@brief No initialization constructor 
</member>
        <member name="F:btTransform.m_origin">
Storage for the translation
</member>
        <member name="F:btTransform.m_basis">
Storage for the rotation
</member>
        <member name="T:btTransform">
@brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
 *It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes. 
</member>
        <member name="T:btMatrix3x3DoubleData">
for serialization
</member>
        <member name="T:btMatrix3x3FloatData">
for serialization
</member>
        <member name="M:op_Equality(btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Equality operator between two matrices
* It will test all elements are equal.  
</member>
        <member name="M:btMatrix3x3.cofac(System.Int32,System.Int32,System.Int32,System.Int32)">
@brief Calculate the matrix cofactor 
	* @param r1 The first row to use for calculating the cofactor
	* @param c1 The first column to use for calculating the cofactor
	* @param r1 The second row to use for calculating the cofactor
	* @param c1 The second column to use for calculating the cofactor
	* See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details

</member>
        <member name="M:btMatrix3x3.diagonalize(btMatrix3x3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Int32)">
@brief diagonalizes this matrix by the Jacobi method.
	* @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
	* coordinate system, i.e., old_this = rot * new_this * rot^T. 
	* @param threshold See iteration
	* @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied 
	* by the sum of the absolute values of the diagonal, or when maxSteps have been executed. 
	* 
	* Note that this matrix is assumed to be symmetric. 

</member>
        <member name="M:btMatrix3x3.solve33(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Solve A * x = b, where b is a column vector. This is more efficient
than computing the inverse in one-shot cases.
Solve33 is from Box2d, thanks to Erin Catto,
</member>
        <member name="M:btMatrix3x3.inverse">
@brief Return the inverse of the matrix 
</member>
        <member name="M:btMatrix3x3.transpose">
@brief Return the transpose of the matrix 
</member>
        <member name="M:btMatrix3x3.absolute">
@brief Return the matrix with all values non negative 
</member>
        <member name="M:btMatrix3x3.adjoint">
@brief Return the adjoint of the matrix 
</member>
        <member name="M:btMatrix3x3.determinant">
@brief Return the determinant of the matrix 
</member>
        <member name="M:btMatrix3x3.scaled(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Create a scaled copy of the matrix 
	* @param s Scaling vector The elements of the vector will scale each column 
</member>
        <member name="M:btMatrix3x3.getEulerZYX(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
@brief Get the matrix represented as euler angles around ZYX
	* @param yaw Yaw around X axis
	* @param pitch Pitch around Y axis
	* @param roll around X axis 
	* @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values
</member>
        <member name="M:btMatrix3x3.getEulerYPR(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Get the matrix represented as euler angles around YXZ, roundtrip with setEulerYPR
	* @param yaw Yaw around Y axis
	* @param pitch Pitch around X axis
	* @param roll around Z axis 
</member>
        <member name="M:btMatrix3x3.getRotation(btQuaternion*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Get the matrix represented as a quaternion 
	* @param q The quaternion which will be set 
</member>
        <member name="M:btMatrix3x3.getOpenGLSubMatrix(System.Single*)">
@brief Fill the rotational part of an OpenGL matrix and clear the shear/perspective
	* @param m The array to be filled 
</member>
        <member name="M:btMatrix3x3.setIdentity">
@brief Set the matrix to the identity 
</member>
        <member name="M:btMatrix3x3.setEulerZYX(System.Single,System.Single,System.Single)">
@brief Set the matrix from euler angles YPR around ZYX axes
	* @param eulerX Roll about X axis
	* @param eulerY Pitch around Y axis
	* @param eulerZ Yaw aboud Z axis
	* 
	* These angles are used to produce a rotation matrix. The euler
	* angles are applied in ZYX order. I.e a vector is first rotated 
	* about X then Y and then Z
	*
</member>
        <member name="M:btMatrix3x3.setEulerYPR(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the matrix from euler angles using YPR around YXZ respectively
	*  @param yaw Yaw about Y axis
	*  @param pitch Pitch about X axis
	*  @param roll Roll about Z axis 

</member>
        <member name="M:btMatrix3x3.setRotation(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the matrix from a quaternion
	*  @param q The Quaternion to match 
</member>
        <member name="M:btMatrix3x3.setValue(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServ">
@brief Set the values of the matrix explicitly (row major)
	*  @param xx Top left
	*  @param xy Top Middle
	*  @param xz Top Right
	*  @param yx Middle Left
	*  @param yy Middle Middle
	*  @param yz Middle Right
	*  @param zx Bottom Left
	*  @param zy Bottom Middle
	*  @param zz Bottom Right
</member>
        <member name="M:btMatrix3x3.setFromOpenGLSubMatrix(System.Single!System.Runtime.CompilerServices.IsConst*)">
@brief Set from the rotational part of a 4x4 OpenGL matrix
	*  @param m A pointer to the beginning of the array of scalars
</member>
        <member name="M:btMatrix3x3.op_SubtractionAssignment(btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Substractss by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this - m 
</member>
        <member name="M:btMatrix3x3.op_AdditionAssignment(btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Adds by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this + m 
</member>
        <member name="M:btMatrix3x3.op_MultiplicationAssignment(btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Multiply by the target matrix on the right
	*  @param m Rotation matrix to be applied 
	* Equivilant to this = this * m 
</member>
        <member name="M:btMatrix3x3.op_Subscript(System.Int32)">
@brief Get a mutable reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed 

@brief Get a const reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed 
</member>
        <member name="M:btMatrix3x3.getRow(System.Int32)">
@brief Get a row of the matrix as a vector 
	*  @param i Row number 0 indexed 
</member>
        <member name="M:btMatrix3x3.getColumn(System.Int32)">
@brief Get a column of the matrix as a vector 
	*  @param i Column number 0 indexed 
</member>
        <member name="M:btMatrix3x3.op_Assign(btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Assignment Operator 
</member>
        <member name="M:btMatrix3x3.#ctor(btMatrix3x3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Copy constructor 
</member>
        <member name="M:btMatrix3x3.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerService">
@brief Constructor with row major formatting 
</member>
        <member name="M:btMatrix3x3.#ctor(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Constructor from Quaternion 
</member>
        <member name="M:btMatrix3x3.#ctor">
@brief No initializaion constructor 
</member>
        <member name="F:btMatrix3x3.m_el">
Data storage for the matrix, each vector is a row of the matrix
</member>
        <member name="T:btMatrix3x3">
@brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
* Make sure to only include a pure orthogonal matrix without scaling. 
</member>
        <member name="M:slerp(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the result of spherical linear interpolation betwen two quaternions 
 * @param q1 The first quaternion
 * @param q2 The second quaternion 
 * @param t The ration between q1 and q2.  t = 0 return q1, t=1 returns q2 
 * Slerp assumes constant velocity between positions. 
</member>
        <member name="M:inverse(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the inverse of a quaternion
</member>
        <member name="M:btAngle(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the angle between two quaternions
</member>
        <member name="M:length(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the length of a quaternion 
</member>
        <member name="M:dot(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Calculate the dot product between two quaternions 
</member>
        <member name="M:op_Multiply(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the product of two quaternions 
</member>
        <member name="M:btQuaternion.slerp(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
   * @param q The other quaternion to interpolate with 
   * @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
   * Slerp interpolates assuming constant velocity.  
</member>
        <member name="M:btQuaternion.nearest(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@todo document this and it's use 
</member>
        <member name="M:btQuaternion.farthest(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@todo document this and it's use 
</member>
        <member name="M:btQuaternion.op_UnaryNegation">
@brief Return the negative of this quaternion 
   * This simply negates each element 
</member>
        <member name="M:btQuaternion.op_Subtraction(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the difference between this quaternion and the other 
   * @param q2 The other quaternion 
</member>
        <member name="M:btQuaternion.op_Addition(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the sum of this quaternion and the other 
   * @param q2 The other quaternion 
</member>
        <member name="M:btQuaternion.inverse">
@brief Return the inverse of this quaternion 
</member>
        <member name="M:btQuaternion.getAxis">
@brief Return the axis of the rotation represented by this quaternion 
</member>
        <member name="M:btQuaternion.getAngleShortestPath">
@brief Return the angle [0, Pi] of rotation represented by this quaternion along the shortest path 
</member>
        <member name="M:btQuaternion.getAngle">
@brief Return the angle [0, 2Pi] of rotation represented by this quaternion 
</member>
        <member name="M:btQuaternion.angleShortestPath(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the angle between this quaternion and the other along the shortest path
	* @param q The other quaternion 
</member>
        <member name="M:btQuaternion.angle(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the ***half*** angle between this quaternion and the other
   * @param q The other quaternion 
</member>
        <member name="M:btQuaternion.normalized">
@brief Return a normalized version of this quaternion 
</member>
        <member name="M:btQuaternion.op_DivisionAssignment(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Inversely scale this quaternion
   * @param s The scale factor 
</member>
        <member name="M:btQuaternion.op_Division(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return an inversely scaled versionof this quaternion
   * @param s The inverse scale factor 
</member>
        <member name="M:btQuaternion.op_Multiply(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return a scaled version of this quaternion
   * @param s The scale factor 
</member>
        <member name="M:btQuaternion.normalize">
@brief Normalize the quaternion 
   * Such that x^2 + y^2 + z^2 +w^2 = 1 
</member>
        <member name="M:btQuaternion.length">
@brief Return the length of the quaternion 
</member>
        <member name="M:btQuaternion.length2">
@brief Return the length squared of the quaternion 
</member>
        <member name="M:btQuaternion.dot(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the dot product between this quaternion and another
   * @param q The other quaternion 
</member>
        <member name="M:btQuaternion.op_MultiplicationAssignment(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Multiply this quaternion by q on the right
   * @param q The other quaternion 
   * Equivilant to this = this * q 
</member>
        <member name="M:btQuaternion.op_MultiplicationAssignment(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Scale this quaternion
   * @param s The scalar to scale by 
</member>
        <member name="M:btQuaternion.op_SubtractionAssignment(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Subtract out a quaternion
   * @param q The quaternion to subtract from this one 
</member>
        <member name="M:btQuaternion.op_AdditionAssignment(btQuaternion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Add two quaternions
   * @param q The quaternion to add to this one 
</member>
        <member name="M:btQuaternion.setEulerZYX(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the quaternion using euler angles 
   * @param yaw Angle around Z
   * @param pitch Angle around Y
   * @param roll Angle around X 
</member>
        <member name="M:btQuaternion.setEuler(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the quaternion using Euler angles
   * @param yaw Angle around Y
   * @param pitch Angle around X
   * @param roll Angle around Z 
</member>
        <member name="M:btQuaternion.setRotation(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the rotation using axis angle notation 
   * @param axis The axis around which to rotate
   * @param angle The magnitude of the rotation in Radians 
</member>
        <member name="M:btQuaternion.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Constructor from Euler angles
   * @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
   * @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
   * @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X 
</member>
        <member name="M:btQuaternion.#ctor(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Axis angle Constructor
   * @param axis The axis which the rotation is around
   * @param angle The magnitude of the rotation around the angle (Radians) 
</member>
        <member name="M:btQuaternion.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Constructor from scalars 
</member>
        <member name="M:btQuaternion.#ctor">
@brief No initialization constructor 
</member>
        <member name="T:btQuaternion">
@brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform. 
</member>
        <member name="M:btQuadWord.setMin(btQuadWord!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set each element to the min of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 

</member>
        <member name="M:btQuadWord.setMax(btQuadWord!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set each element to the max of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 

</member>
        <member name="M:btQuadWord.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Initializing constructor
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w

</member>
        <member name="M:btQuadWord.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Three argument constructor (zeros w)
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z

</member>
        <member name="M:btQuadWord.#ctor">
@brief No initialization constructor 
</member>
        <member name="M:btQuadWord.setValue(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w

</member>
        <member name="M:btQuadWord.setValue(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z

</member>
        <member name="M:btQuadWord.op_Implicit~System.Single*">
operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
</member>
        <member name="M:btQuadWord.w">
@brief Return the w value 
</member>
        <member name="M:btQuadWord.z">
@brief Return the z value 
</member>
        <member name="M:btQuadWord.y">
@brief Return the y value 
</member>
        <member name="M:btQuadWord.x">
@brief Return the x value 
</member>
        <member name="M:btQuadWord.setW(System.Single)">
@brief Set the w value 
</member>
        <member name="M:btQuadWord.setZ(System.Single)">
@brief Set the z value 
</member>
        <member name="M:btQuadWord.setY(System.Single)">
@brief Set the y value 
</member>
        <member name="M:btQuadWord.setX(System.Single)">
@brief Set the x value 
</member>
        <member name="M:btQuadWord.getZ">
@brief Return the z value 
</member>
        <member name="M:btQuadWord.getY">
@brief Return the y value 
</member>
        <member name="M:btQuadWord.getX">
@brief Return the x value 
</member>
        <member name="T:btQuadWord">
@brief The btQuadWord class is base class for btVector3 and btQuaternion. 
 * Some issues under PS3 Linux with IBM 2.1 SDK, gcc compiler prevent from using aligned quadword.

</member>
        <member name="M:btUnSwapVector3Endian(btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
btUnSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
</member>
        <member name="M:btSwapVector3Endian(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
</member>
        <member name="M:btSwapScalarEndian(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
</member>
        <member name="M:btVector4.setValue(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z

@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w

</member>
        <member name="M:lerp(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the linear interpolation between two vectors
 * @param v1 One vector 
 * @param v2 The other vector 
 * @param t The ration of this to v (t = 0 =&gt; return v1, t=1 =&gt; return v2) 
</member>
        <member name="M:btCross(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the cross product of two vectors 
</member>
        <member name="M:btAngle(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the angle between two vectors 
</member>
        <member name="M:btDistance(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the distance between two vectors 
</member>
        <member name="M:btDistance2(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the distance squared between two vectors 
</member>
        <member name="M:btDot(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the dot product between two vectors 
</member>
        <member name="M:op_Division(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the vector inversely scaled by s 
</member>
        <member name="M:op_Division(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the vector inversely scaled by s 
</member>
        <member name="M:op_Multiply(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the vector scaled by s 
</member>
        <member name="M:op_Multiply(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the vector scaled by s 
</member>
        <member name="M:op_UnaryNegation(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the negative of the vector 
</member>
        <member name="M:op_Subtraction(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the difference between two vectors 
</member>
        <member name="M:op_Multiply(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the elementwise product of two vectors 
</member>
        <member name="M:op_Addition(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the sum of two vectors (Point symantics)
</member>
        <member name="M:btVector3.minDot(btVector3!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief returns index of minimum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The minimum dot product 
</member>
        <member name="M:btVector3.maxDot(btVector3!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief returns index of maximum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The maximum dot product 
</member>
        <member name="M:btVector3.setMin(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set each element to the min of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 

</member>
        <member name="M:btVector3.setMax(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Set each element to the max of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 

</member>
        <member name="M:btVector3.op_Implicit~System.Single*">
operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
</member>
        <member name="M:btVector3.w">
@brief Return the w value 
</member>
        <member name="M:btVector3.z">
@brief Return the z value 
</member>
        <member name="M:btVector3.y">
@brief Return the y value 
</member>
        <member name="M:btVector3.x">
@brief Return the x value 
</member>
        <member name="M:btVector3.setW(System.Single)">
@brief Set the w value 
</member>
        <member name="M:btVector3.setZ(System.Single)">
@brief Set the z value 
</member>
        <member name="M:btVector3.setY(System.Single)">
@brief Set the y value 
</member>
        <member name="M:btVector3.setX(System.Single)">
@brief Set the x value 
</member>
        <member name="M:btVector3.getZ">
@brief Return the z value 
</member>
        <member name="M:btVector3.getY">
@brief Return the y value 
</member>
        <member name="M:btVector3.getX">
@brief Return the x value 
</member>
        <member name="M:btVector3.op_MultiplicationAssignment(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Elementwise multiply this vector by the other 
   * @param v The other vector 
</member>
        <member name="M:btVector3.lerp(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the linear interpolation between this and another vector 
   * @param v The other vector 
   * @param t The ration of this to v (t = 0 =&gt; return this, t=1 =&gt; return other) 
</member>
        <member name="M:btVector3.maxAxis">
@brief Return the axis with the largest value 
   * Note return values are 0,1,2 for x, y, or z 
</member>
        <member name="M:btVector3.minAxis">
@brief Return the axis with the smallest value 
   * Note return values are 0,1,2 for x, y, or z 
</member>
        <member name="M:btVector3.cross(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the cross product between this and another vector 
   * @param v The other vector 
</member>
        <member name="M:btVector3.absolute">
@brief Return a vector will the absolute values of each element 
</member>
        <member name="M:btVector3.angle(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the angle between this and another vector
   * @param v The other vector 
</member>
        <member name="M:btVector3.rotate(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst)">
@brief Return a rotated version of this vector
   * @param wAxis The axis to rotate about 
   * @param angle The angle to rotate by 
</member>
        <member name="M:btVector3.normalized">
@brief Return a normalized version of this vector 
</member>
        <member name="M:btVector3.normalize">
@brief Normalize this vector 
   * x^2 + y^2 + z^2 = 1 
</member>
        <member name="M:btVector3.distance(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the distance between the ends of this and another vector
   * This is symantically treating the vector like a point 
</member>
        <member name="M:btVector3.distance2(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the distance squared between the ends of this and another vector
   * This is symantically treating the vector like a point 
</member>
        <member name="M:btVector3.safeNorm">
@brief Return the norm (length) of the vector 
</member>
        <member name="M:btVector3.norm">
@brief Return the norm (length) of the vector 
</member>
        <member name="M:btVector3.length">
@brief Return the length of the vector 
</member>
        <member name="M:btVector3.length2">
@brief Return the length of the vector squared 
</member>
        <member name="M:btVector3.dot(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Return the dot product
   * @param v The other vector in the dot product 
</member>
        <member name="M:btVector3.op_DivisionAssignment(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Inversely scale the vector 
   * @param s Scale factor to divide by 
</member>
        <member name="M:btVector3.op_MultiplicationAssignment(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Scale the vector
   * @param s Scale factor 
</member>
        <member name="M:btVector3.op_SubtractionAssignment(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Subtract a vector from this one
   * @param The vector to subtract 
</member>
        <member name="M:btVector3.op_AdditionAssignment(btVector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Add a vector to this one 
 * @param The vector to add to this one 
</member>
        <member name="M:btVector3.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Constructor from scalars 
   * @param x X value
   * @param y Y value 
   * @param z Z value 

</member>
        <member name="M:btVector3.#ctor">
@brief No initialization constructor 
</member>
        <member name="T:btVector3">
@brief btVector3 can be used to represent 3D points and vectors.
 * It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
 * Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers

</member>
        <member name="M:btAlignedAllocSetCustomAligned(=FUNC:System.Void*(System.UInt32,System.Int32),=FUNC:System.Void(System.Void*))">
If the developer has already an custom aligned allocator, then btAlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
</member>
        <member name="M:btAlignedAllocSetCustom(=FUNC:System.Void*(System.UInt32),=FUNC:System.Void(System.Void*))">
The developer can let all Bullet memory allocations go through a custom memory allocator, using btAlignedAllocSetCustom
</member>
        <member name="M:btAlignedAllocInternal(System.UInt32,System.Int32)">
we probably replace this with our own aligned memory allocator
so we replace _aligned_malloc and _aligned_free with our own
that is better portable and more predictable
BT_DEBUG_MEMORY_ALLOCATIONS preprocessor can be set in build system
for regression tests to detect memory leaks
#define BT_DEBUG_MEMORY_ALLOCATIONS 1
</member>
        <member name="T:btTypedObject">
rudimentary class to provide type info
</member>
        <member name="M:btSwapEndianFloat(System.Single)">
btSwapFloat uses using char pointers to swap the endianness
Not all values of sign/exponent/mantissa are valid floating point numbers according to IEEE 754. 
When a floating point unit is faced with an invalid value, it may actually change the value, or worse, throw an exception. 
In most systems, running user mode code, you wouldn't get an exception, but instead the hardware/os/runtime will 'fix' the number for you. 
so instead of returning a float/double, we return integer/long long integer
</member>
        <member name="M:btSelect(System.UInt32,System.UInt32,System.UInt32)">
btSelect avoids branches, which makes performance much better for consoles like Playstation 3 and XBox 360
Thanks Phil Knight. See also http://www.cellperformance.com/articles/2006/04/more_techniques_for_eliminatin_1.html
</member>
        <member name="D:btScalar">
The btScalar type abstracts floating point numbers, to easily switch between double and single floating point precision.
</member>
        <member name="T:btCollisionShape">
Common headerfile includes for Bullet Collision Detection
Bullet's btCollisionWorld and btCollisionObject definitions
 @mainpage Bullet Documentation

 @section intro_sec Introduction
 Bullet is a Collision Detection and Rigid Body Dynamics Library. The Library is Open Source and free for commercial use, under the ZLib license ( http://opensource.org/licenses/zlib-license.php ).

 The main documentation is Bullet_User_Manual.pdf, included in the source code distribution.
 There is the Physics Forum for feedback and general Collision Detection and Physics discussions.
 Please visit http://www.bulletphysics.org

 @section install_sec Installation

 @subsection step1 Step 1: Download
 You can download the Bullet Physics Library from the github repository: https://github.com/bulletphysics/bullet3/releases 

 @subsection step2 Step 2: Building
 Bullet has multiple build systems, including premake, cmake and autotools. Premake and cmake support all platforms.
 Premake is included in the Bullet/build folder for Windows, Mac OSX and Linux. 
 Under Windows you can click on Bullet/build/vs2010.bat to create Microsoft Visual Studio projects. 
 On Mac OSX and Linux you can open a terminal and generate Makefile, codeblocks or Xcode4 projects:
 cd Bullet/build
 ./premake4_osx gmake or ./premake4_linux gmake or ./premake4_linux64 gmake or (for Mac) ./premake4_osx xcode4
 cd Bullet/build/gmake
 make
 
 An alternative to premake is cmake. You can download cmake from http://www.cmake.org
 cmake can autogenerate projectfiles for Microsoft Visual Studio, Apple Xcode, KDevelop and Unix Makefiles.
 The easiest is to run the CMake cmake-gui graphical user interface and choose the options and generate projectfiles.
 You can also use cmake in the command-line. Here are some examples for various platforms:
 cmake . -G "Visual Studio 9 2008"
 cmake . -G Xcode
 cmake . -G "Unix Makefiles"
 Although cmake is recommended, you can also use autotools for UNIX: ./autogen.sh ./configure to create a Makefile and then run make.
 
 @subsection step3 Step 3: Testing demos
 Try to run and experiment with BasicDemo executable as a starting point.
 Bullet can be used in several ways, as Full Rigid Body simulation, as Collision Detector Library or Low Level / Snippets like the GJK Closest Point calculation.
 The Dependencies can be seen in this documentation under Directories
 
 @subsection step4 Step 4: Integrating in your application, full Rigid Body and Soft Body simulation
 Check out BasicDemo how to create a btDynamicsWorld, btRigidBody and btCollisionShape, Stepping the simulation and synchronizing your graphics object transform.
 Check out SoftDemo how to use soft body dynamics, using btSoftRigidDynamicsWorld.
 @subsection step5 Step 5 : Integrate the Collision Detection Library (without Dynamics and other Extras)
 Bullet Collision Detection can also be used without the Dynamics/Extras.
 Check out btCollisionWorld and btCollisionObject, and the CollisionInterfaceDemo.
 @subsection step6 Step 6 : Use Snippets like the GJK Closest Point calculation.
 Bullet has been designed in a modular way keeping dependencies to a minimum. The ConvexHullDistance demo demonstrates direct use of btGjkPairDetector.

 @section copyright Copyright
 For up-to-data information and copyright and contributors list check out the Bullet_User_Manual.pdf
 


btCollisionObjectWrapperis an internal data structure. 
Most users can ignore this and use btCollisionObject and btCollisionShape instead

The btCollisionShape class provides an interface for collision shapes that can be shared among btCollisionObjects.
</member>
        <member name="F:aiAnimation.mMeshChannels">
The mesh animation channels. Each channel affects a single mesh. 
	 *  The array is mNumMeshChannels in size. 
</member>
        <member name="F:aiAnimation.mNumMeshChannels">
The number of mesh animation channels. Each channel affects
	 *  a single mesh and defines vertex-based animation. 
</member>
        <member name="F:aiAnimation.mChannels">
The node animation channels. Each channel affects a single node. 
	 *  The array is mNumChannels in size. 
</member>
        <member name="F:aiAnimation.mNumChannels">
The number of bone animation channels. Each channel affects
	 *  a single node. 
</member>
        <member name="F:aiAnimation.mTicksPerSecond">
Ticks per second. 0 if not specified in the imported file 
</member>
        <member name="F:aiAnimation.mDuration">
Duration of the animation in ticks.  
</member>
        <member name="F:aiAnimation.mName">
The name of the animation. If the modeling package this data was 
	 *  exported from does support only a single animation channel, this 
	 *  name is usually empty (length is zero). 
</member>
        <member name="T:aiAnimation">
An animation consists of keyframe data for a number of nodes. For 
 *  each node affected by the animation a separate series of data is given.
</member>
        <member name="F:aiMeshAnim.mKeys">
Key frames of the animation. May not be NULL. 
</member>
        <member name="F:aiMeshAnim.mNumKeys">
Size of the #mKeys array. Must be 1, at least. 
</member>
        <member name="F:aiMeshAnim.mName">
Name of the mesh to be animated. An empty string is not allowed,
	 *  animated meshes need to be named (not necessarily uniquely,
	 *  the name can basically serve as wildcard to select a group
	 *  of meshes with similar animation setup)
</member>
        <member name="T:aiMeshAnim">
Describes vertex-based animations for a single mesh or a group of
 *  meshes. Meshes carry the animation data for each frame in their
 *  aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to 
 *  define keyframes linking each mesh attachment to a particular
 *  point in time. 
</member>
        <member name="F:aiNodeAnim.mPostState">
Defines how the animation behaves after the last 
	 *  key was processed.
	 *
	 *  The default value is aiAnimBehaviour_DEFAULT (the original
	 *  transformation matrix of the affected node is taken).
</member>
        <member name="F:aiNodeAnim.mPreState">
Defines how the animation behaves before the first
	 *  key is encountered.
	 *
	 *  The default value is aiAnimBehaviour_DEFAULT (the original
	 *  transformation matrix of the affected node is used).
</member>
        <member name="F:aiNodeAnim.mScalingKeys">
The scaling keys of this animation channel. Scalings are 
	 *  specified as 3D vector. The array is mNumScalingKeys in size.
	 *
	 * If there are scaling keys, there will also be at least one
	 * position and one rotation key.
</member>
        <member name="F:aiNodeAnim.mNumScalingKeys">
The number of scaling keys 
</member>
        <member name="F:aiNodeAnim.mRotationKeys">
The rotation keys of this animation channel. Rotations are 
	 *  given as quaternions,  which are 4D vectors. The array is 
	 *  mNumRotationKeys in size.
	 *
	 * If there are rotation keys, there will also be at least one
	 * scaling and one position key. 
</member>
        <member name="F:aiNodeAnim.mNumRotationKeys">
The number of rotation keys 
</member>
        <member name="F:aiNodeAnim.mPositionKeys">
The position keys of this animation channel. Positions are 
	 * specified as 3D vector. The array is mNumPositionKeys in size.
	 *
	 * If there are position keys, there will also be at least one
	 * scaling and one rotation key.
</member>
        <member name="F:aiNodeAnim.mNumPositionKeys">
The number of position keys 
</member>
        <member name="F:aiNodeAnim.mNodeName">
The name of the node affected by this animation. The node 
	 *  must exist and it must be unique.
</member>
        <member name="T:aiNodeAnim">
Describes the animation of a single node. The name specifies the 
 *  bone/node which is affected by this animation channel. The keyframes
 *  are given in three separate series of values, one each for position, 
 *  rotation and scaling. The transformation matrix computed from these
 *  values replaces the node's original transformation matrix at a
 *  specific time.
 *  This means all keys are absolute and not relative to the bone default pose.
 *  The order in which the transformations are applied is
 *  - as usual - scaling, rotation, translation.
 *
 *  @note All keys are returned in their correct, chronological order.
 *  Duplicate keys don't pass the validation step. Most likely there
 *  will be no negative time values, but they are not forbidden also ( so 
 *  implementations need to cope with them! ) 
</member>
        <member name="T:aiAnimBehaviour">
Defines how an animation channel behaves outside the defined time
 *  range. This corresponds to aiNodeAnim::mPreState and 
 *  aiNodeAnim::mPostState.
</member>
        <member name="F:_aiAnimBehaviour_Force32Bit">
This value is not used, it is just here to force the
	 *  the compiler to map this enum to a 32 Bit integer  
</member>
        <member name="F:aiAnimBehaviour_REPEAT">
The animation is repeated.
	 *
	 *  If the animation key go from n to m and the current
	 *  time is t, use the value at (t-n) % (|m-n|).
</member>
        <member name="F:aiAnimBehaviour_LINEAR">
The value of the nearest two keys is linearly
	 *  extrapolated for the current time value.
</member>
        <member name="F:aiAnimBehaviour_CONSTANT">
The nearest key value is used without interpolation 
</member>
        <member name="F:aiAnimBehaviour_DEFAULT">
The value from the default node transformation is taken
</member>
        <member name="M:aiMeshKey.#ctor(System.Double,System.UInt32!System.Runtime.CompilerServices.IsConst)">
Construction from a given time and key value 
</member>
        <member name="F:aiMeshKey.mValue">
Index into the aiMesh::mAnimMeshes array of the 
	 *  mesh coresponding to the #aiMeshAnim hosting this
	 *  key frame. The referenced anim mesh is evaluated
	 *  according to the rules defined in the docs for #aiAnimMesh.
</member>
        <member name="F:aiMeshKey.mTime">
The time of this key 
</member>
        <member name="T:aiMeshKey">
Binds a anim mesh to a specific point in time. 
</member>
        <member name="M:aiQuatKey.#ctor(System.Double,aiQuaterniont&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Construction from a given time and key value 
</member>
        <member name="F:aiQuatKey.mValue">
The value of this key 
</member>
        <member name="F:aiQuatKey.mTime">
The time of this key 
</member>
        <member name="T:aiQuatKey">
A time-value pair specifying a rotation for the given time. 
 *  Rotations are expressed with quaternions. 
</member>
        <member name="F:aiVectorKey.mValue">
The value of this key 
</member>
        <member name="F:aiVectorKey.mTime">
The time of this key 
</member>
        <member name="T:aiVectorKey">
@file anim.h
 *  @brief Defines the data structures in which the imported animations
 *  are returned.

A time-value pair specifying a certain 3D vector for the given time. 
</member>
        <member name="M:aiGetMaterialTexture(aiMaterial!System.Runtime.CompilerServices.IsConst*,aiTextureType,System.UInt32,aiString*,aiTextureMapping*,System.UInt32*,System.Single*,aiTextureOp*,aiTextureMapMode*,System.UInt32*)">
@brief Helper function to get all values pertaining to a particular
 *  texture slot from a material structure.
 *
 *  This function is provided just for convenience. You could also read the
 *  texture by parsing all of its properties manually. This function bundles
 *  all of them in a huge function monster.
 *
 *  @param[in] mat Pointer to the input material. May not be NULL
 *  @param[in] type Specifies the texture stack to read from (e.g. diffuse,
 *     specular, height map ...). 
 *  @param[in] index Index of the texture. The function fails if the 
 *     requested index is not available for this texture type. 
 *     #aiGetMaterialTextureCount() can be used to determine the number of
 *     textures in a particular texture stack.
 *  @param[out] path Receives the output path
 *      This parameter must be non-null.
 *  @param mapping The texture mapping mode to be used.
 *      Pass NULL if you're not interested in this information.
 *  @param[out] uvindex For UV-mapped textures: receives the index of the UV
 *      source channel. Unmodified otherwise.
 *      Pass NULL if you're not interested in this information.
 *  @param[out] blend Receives the blend factor for the texture
 *      Pass NULL if you're not interested in this information.
 *  @param[out] op Receives the texture blend operation to be perform between
 *		this texture and the previous texture.
 *      Pass NULL if you're not interested in this information.
 *  @param[out] mapmode Receives the mapping modes to be used for the texture.
 *      Pass NULL if you're not interested in this information. Otherwise,
 *      pass a pointer to an array of two aiTextureMapMode's (one for each
 *      axis, UV order).
 *  @return AI_SUCCESS on success, otherwise something else. Have fun.
</member>
        <member name="M:aiGetMaterialTextureCount(aiMaterial!System.Runtime.CompilerServices.IsConst*,aiTextureType)">
Get the number of textures for a particular texture type.
 *  @param[in] pMat Pointer to the input material. May not be NULL
 *  @param type Texture type to check for
 *  @return Number of textures for this type.
 *  @note A texture can be easily queried using #aiGetMaterialTexture() 
</member>
        <member name="M:aiGetMaterialString(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,aiString*)">
@brief Retrieve a string from the material property table
*
* See the sample for aiGetMaterialFloat for more information.
</member>
        <member name="M:aiGetMaterialColor(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,aiColor4t&lt;System.Single&gt;*)">
@brief Retrieve a color value from the material property table
*
* See the sample for aiGetMaterialFloat for more information
</member>
        <member name="M:aiGetMaterialInteger(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Int32*)">
@brief Retrieve an integer property with a specific key from a material
 *
 * See the sample for aiGetMaterialFloat for more information.
</member>
        <member name="M:aiGetMaterialIntegerArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Int32*,System.UInt32*)">
@brief Retrieve an array of integer values with a specific key 
 *  from a material
 *
 * See the sample for aiGetMaterialFloatArray for more information.
</member>
        <member name="M:aiGetMaterialProperty(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,aiMaterialProperty!System.Runtime.CompilerServices.IsConst**)">
@brief Retrieve a material property with a specific key from the material
 *
 * @param pMat Pointer to the input material. May not be NULL
 * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
 * @param type Specifies the type of the texture to be retrieved (
 *    e.g. diffuse, specular, height map ...)
 * @param index Index of the texture to be retrieved.
 * @param pPropOut Pointer to receive a pointer to a valid aiMaterialProperty
 *        structure or NULL if the key has not been found. 
</member>
        <member name="F:aiMaterial.mNumAllocated">
Storage allocated 
</member>
        <member name="F:aiMaterial.mNumProperties">
Number of properties in the data base 
</member>
        <member name="F:aiMaterial.mProperties">
List of all material properties loaded. 
</member>
        <member name="M:aiMaterial.CopyPropertyList(aiMaterial*,aiMaterial!System.Runtime.CompilerServices.IsConst*)">
Copy the property list of a material
	 *  @param pcDest Destination material
	 *  @param pcSrc Source material

</member>
        <member name="M:aiMaterial.Clear">
@brief Removes all properties from the material.
	 *
	 *  The data array remains allocated so adding new properties is quite fast.  
</member>
        <member name="M:aiMaterial.RemoveProperty(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32)">
@brief Remove a given key from the list.
	 *
	 *  The function fails if the key isn't found
	 *  @param pKey Key to be deleted 
</member>
        <member name="M:aiMaterial.AddProperty(aiString!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32)">
@brief Add a string property with a given key and type info to the 
	 *  material structure 
	 *
	 *  @param pInput Input string
	 *  @param pKey Key/Usage of the property (AI_MATKEY_XXX)
	 *  @param type Set by the AI_MATKEY_XXX macro
	 *  @param index Set by the AI_MATKEY_XXX macro 
</member>
        <member name="M:aiMaterial.AddBinaryProperty(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,aiPropertyTypeInfo)">
@brief Add a property with a given key and type info to the material
	 *  structure 
	 *
	 *  @param pInput Pointer to input data
	 *  @param pSizeInBytes Size of input data
	 *  @param pKey Key/Usage of the property (AI_MATKEY_XXX)
	 *  @param type Set by the AI_MATKEY_XXX macro
	 *  @param index Set by the AI_MATKEY_XXX macro
	 *  @param pType Type information hint 
</member>
        <member name="M:aiMaterial.GetTexture(aiTextureType,System.UInt32,aiString*,aiTextureMapping*,System.UInt32*,System.Single*,aiTextureOp*,aiTextureMapMode*)">
Helper function to get all parameters pertaining to a 
	 *  particular texture slot from a material.
	*
	*  This function is provided just for convenience, you could also
	*  read the single material properties manually.
	*  @param type Specifies the type of the texture to be retrieved (
	*    e.g. diffuse, specular, height map ...)
	*  @param index Index of the texture to be retrieved. The function fails
	*    if there is no texture of that type with this index. 
	*    #GetTextureCount() can be used to determine the number of textures
	*    per texture type.
	*  @param path Receives the path to the texture.
	*	 NULL is a valid value.
   *  @param mapping The texture mapping.
   *		NULL is allowed as value.
	*  @param uvindex Receives the UV index of the texture. 
	*    NULL is a valid value.
	*  @param blend Receives the blend factor for the texture
	*	 NULL is a valid value.
	*  @param op Receives the texture operation to be performed between
	*	 this texture and the previous texture. NULL is allowed as value.
	*  @param mapmode Receives the mapping modes to be used for the texture.
	*    The parameter may be NULL but if it is a valid pointer it MUST
	*    point to an array of 3 aiTextureMapMode's (one for each
	*    axis: UVW order (=XYZ)). 


@file aiMaterial.inl
 *  @brief Defines the C++ getters for the material system

</member>
        <member name="M:aiMaterial.GetTextureCount(aiTextureType)">
Get the number of textures for a particular texture type.
	 *  @param type Texture type to check for
	 *  @return Number of textures for this type.
	 *  @note A texture can be easily queried using #GetTexture() 
</member>
        <member name="T:aiMaterial">
@brief Data structure for a material
*
*  Material data is stored using a key-value structure. A single key-value
*  pair is called a 'material property'. C++ users should use the provided
*  member functions of aiMaterial to process material properties, C users
*  have to stick with the aiMaterialGetXXX family of unbound functions.
*  The library defines a set of standard keys (AI_MATKEY_XXX).

</member>
        <member name="F:aiMaterialProperty.mData">
Binary buffer to hold the property's value.
     * The size of the buffer is always mDataLength.

</member>
        <member name="F:aiMaterialProperty.mType">
Type information for the property.
     *
     * Defines the data layout inside the data buffer. This is used
	 * by the library internally to perform debug checks and to 
	 * utilize proper type conversions. 
	 * (It's probably a hacky solution, but it works.)

</member>
        <member name="F:aiMaterialProperty.mDataLength">
Size of the buffer mData is pointing to, in bytes.
	 *  This value may not be 0.

</member>
        <member name="F:aiMaterialProperty.mIndex">
Textures: Specifies the index of the texture.
	 *  For non-texture properties, this member is always 0.

</member>
        <member name="F:aiMaterialProperty.mSemantic">
Textures: Specifies their exact usage semantic.
	 * For non-texture properties, this member is always 0 
	 * (or, better-said, #aiTextureType_NONE).

</member>
        <member name="F:aiMaterialProperty.mKey">
Specifies the name of the property (key)
     *  Keys are generally case insensitive. 

</member>
        <member name="T:aiPropertyTypeInfo">
@brief A very primitive RTTI system for the contents of material 
 *  properties.

</member>
        <member name="F:_aiPTI_Force32Bit">
This value is not used. It is just there to force the
	 *  compiler to map this enum to a 32 Bit integer.

</member>
        <member name="F:aiPTI_Buffer">
Simple binary buffer, content undefined. Not convertible to anything.

</member>
        <member name="F:aiPTI_Integer">
Array of (32 Bit) integers
	 *
	 *  It is possible to use aiGetMaterialFloat[Array]() (or the C++-API 
	 *  aiMaterial::Get()) to query properties stored in integer format. 
	 *  The material system performs the type conversion automatically.

</member>
        <member name="F:aiPTI_String">
The material property is an aiString.
	 *
	 *  Arrays of strings aren't possible, aiGetMaterialString() (or the 
	 *  C++-API aiMaterial::Get()) *must* be used to query a string property.

</member>
        <member name="F:aiPTI_Float">
Array of single-precision (32 Bit) floats
	 *
	 *  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API 
	 *  aiMaterial::Get()) to query properties stored in floating-point format. 
	 *  The material system performs the type conversion automatically.

</member>
        <member name="F:aiUVTransform.mRotation">
Rotation - in counter-clockwise direction.
	 *
	 *  The rotation angle is specified in radians. The
	 *  rotation center is 0.5f|0.5f. The default value
     *  0.f.

</member>
        <member name="F:aiUVTransform.mScaling">
Scaling on the u and v axes. 
	 *
	 *  The default value is (1|1).

</member>
        <member name="F:aiUVTransform.mTranslation">
Translation on the u and v axes. 
	 *
	 *  The default value is (0|0).

</member>
        <member name="T:aiUVTransform">
@brief Defines how an UV channel is transformed.
 *
 *  This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.
 *  See its documentation for more details. 
 *
 *  Typically you'll want to build a matrix of this information. However,
 *  we keep separate scaling/translation/rotation values to make it
 *  easier to process and optimize UV transformations internally.

</member>
        <member name="F:_aiBlendMode_Force32Bit">
@cond never 
	  *  This value is not used. It forces the compiler to use at least
	  *  32 Bit integers to represent this enum.

</member>
        <member name="F:aiBlendMode_Additive">
Additive blending
	 *
	 *  Formula:
	 *  @code
	 *  SourceColor*1 + DestColor*1
	 *  @endcode

</member>
        <member name="F:aiBlendMode_Default">
Formula:
@code
SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)
@endcode

</member>
        <member name="T:aiTextureFlags">
@brief Defines some mixed flags for a particular texture.
 *
 *  Usually you'll instruct your cg artists how textures have to look like ...
 *  and how they will be processed in your application. However, if you use
 *  Assimp for completely generic loading purposes you might also need to 
 *  process these flags in order to display as many 'unknown' 3D models as 
 *  possible correctly.
 *
 *  This corresponds to the #AI_MATKEY_TEXFLAGS property.

</member>
        <member name="F:_aiTextureFlags_Force32Bit">
@cond never 
	  *  This value is not used. It forces the compiler to use at least
	  *  32 Bit integers to represent this enum.

</member>
        <member name="F:aiTextureFlags_IgnoreAlpha">
Explicit request to the application to ignore the alpha channel
	 *  of the texture.
	 *
	 *  Mutually exclusive with #aiTextureFlags_UseAlpha. 

</member>
        <member name="F:aiTextureFlags_UseAlpha">
Explicit request to the application to process the alpha channel
	 *  of the texture.
	 *
	 *  Mutually exclusive with #aiTextureFlags_IgnoreAlpha. These
	 *  flags are set if the library can say for sure that the alpha
	 *  channel is used/is not used. If the model format does not
	 *  define this, it is left to the application to decide whether
	 *  the texture alpha channel - if any - is evaluated or not.

</member>
        <member name="F:aiTextureFlags_Invert">
The texture's color values have to be inverted (componentwise 1-n)

</member>
        <member name="F:_aiShadingMode_Force32Bit">
@cond never 
	  *  This value is not used. It forces the compiler to use at least
	  *  32 Bit integers to represent this enum.

</member>
        <member name="F:aiShadingMode_Fresnel">
Fresnel shading

</member>
        <member name="F:aiShadingMode_NoShading">
No shading at all. Constant light influence of 1.0.

</member>
        <member name="F:aiShadingMode_CookTorrance">
CookTorrance-Shading per pixel
	 *
	 *  Special shader for metallic surfaces.

</member>
        <member name="F:aiShadingMode_Minnaert">
Minnaert-Shading per pixel
     *
     *  Extension to standard Lambertian shading, taking the
     *  "darkness" of the material into account

</member>
        <member name="F:aiShadingMode_OrenNayar">
OrenNayar-Shading per pixel
     *
     *  Extension to standard Lambertian shading, taking the
     *  roughness of the material into account

</member>
        <member name="F:aiShadingMode_Toon">
Toon-Shading per pixel
     *
	 *  Also known as 'comic' shader.

</member>
        <member name="F:aiShadingMode_Blinn">
Phong-Blinn-Shading

</member>
        <member name="F:aiShadingMode_Phong">
Phong-Shading -

</member>
        <member name="F:aiShadingMode_Gouraud">
Simple Gouraud shading. 

</member>
        <member name="F:aiShadingMode_Flat">
Flat shading. Shading is done on per-face base, 
     *  diffuse only. Also known as 'faceted shading'.

</member>
        <member name="F:_aiTextureType_Force32Bit">
@cond never 
	  *  This value is not used. It forces the compiler to use at least
	  *  32 Bit integers to represent this enum.

</member>
        <member name="F:aiTextureType_UNKNOWN">
Unknown texture
	 *
	 *  A texture reference that does not match any of the definitions 
	 *  above is considered to be 'unknown'. It is still imported,
	 *  but is excluded from any further postprocessing.

</member>
        <member name="F:aiTextureType_REFLECTION">
Reflection texture
	 *
	 * Contains the color of a perfect mirror reflection.
	 * Rarely used, almost never for real-time applications.

</member>
        <member name="F:aiTextureType_LIGHTMAP">
Lightmap texture (aka Ambient Occlusion)
	 *
	 *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are
	 *  covered by this material property. The texture contains a
	 *  scaling value for the final color value of a pixel. Its
	 *  intensity is not affected by incoming light.

</member>
        <member name="F:aiTextureType_DISPLACEMENT">
Displacement texture
	 *
	 *  The exact purpose and format is application-dependent.
     *  Higher color values stand for higher vertex displacements.

</member>
        <member name="F:aiTextureType_OPACITY">
The texture defines per-pixel opacity.
	 *
	 *  Usually 'white' means opaque and 'black' means 
	 *  'transparency'. Or quite the opposite. Have fun.

</member>
        <member name="F:aiTextureType_SHININESS">
The texture defines the glossiness of the material.
	 *
	 *  The glossiness is in fact the exponent of the specular
	 *  (phong) lighting equation. Usually there is a conversion
	 *  function defined to map the linear color values in the
	 *  texture to a suitable exponent. Have fun.

</member>
        <member name="F:aiTextureType_NORMALS">
The texture is a (tangent space) normal-map.
	 *
	 *  Again, there are several conventions for tangent-space
	 *  normal maps. Assimp does (intentionally) not 
	 *  distinguish here.

</member>
        <member name="F:aiTextureType_HEIGHT">
The texture is a height map.
	 *
	 *  By convention, higher gray-scale values stand for
	 *  higher elevations from the base height.

</member>
        <member name="F:aiTextureType_EMISSIVE">
The texture is added to the result of the lighting
	 *  calculation. It isn't influenced by incoming light.

</member>
        <member name="F:aiTextureType_AMBIENT">
The texture is combined with the result of the ambient
	 *  lighting equation.

</member>
        <member name="F:aiTextureType_SPECULAR">
The texture is combined with the result of the specular
	 *  lighting equation.

</member>
        <member name="F:aiTextureType_DIFFUSE">
The texture is combined with the result of the diffuse
	 *  lighting equation.

</member>
        <member name="F:aiTextureType_NONE">
Dummy value.
	 *
	 *  No texture, but the value to be used as 'texture semantic' 
	 *  (#aiMaterialProperty::mSemantic) for all material properties 
	 *  *not* related to textures.

</member>
        <member name="T:aiTextureMapping">
@brief Defines how the mapping coords for a texture are generated.
 *
 *  Real-time applications typically require full UV coordinates, so the use of
 *  the aiProcess_GenUVCoords step is highly recommended. It generates proper
 *  UV channels for non-UV mapped objects, as long as an accurate description
 *  how the mapping should look like (e.g spherical) is given.
 *  See the #AI_MATKEY_MAPPING property for more details.

</member>
        <member name="F:_aiTextureMapping_Force32Bit">
@cond never 
	  *  This value is not used. It forces the compiler to use at least
	  *  32 Bit integers to represent this enum.

</member>
        <member name="F:aiTextureMapping_OTHER">
Undefined mapping. Have fun. 
</member>
        <member name="F:aiTextureMapping_PLANE">
Planar mapping 
</member>
        <member name="F:aiTextureMapping_BOX">
Cubic mapping 
</member>
        <member name="F:aiTextureMapping_CYLINDER">
Cylindrical mapping 
</member>
        <member name="F:aiTextureMapping_SPHERE">
Spherical mapping 
</member>
        <member name="F:aiTextureMapping_UV">
The mapping coordinates are taken from an UV channel.
	 *
	 *  The #AI_MATKEY_UVWSRC key specifies from which UV channel
	 *  the texture coordinates are to be taken from (remember,
	 *  meshes can have more than one UV channel). 

</member>
        <member name="T:aiTextureMapMode">
@brief Defines how UV coordinates outside the [0...1] range are handled.
 *
 *  Commonly refered to as 'wrapping mode'.

</member>
        <member name="F:_aiTextureMapMode_Force32Bit">
@cond never 
	  *  This value is not used. It forces the compiler to use at least
	  *  32 Bit integers to represent this enum.

</member>
        <member name="F:aiTextureMapMode_Mirror">
A texture coordinate u|v becomes u%1|v%1 if (u-(u%1))%2 is zero and
     *  1-(u%1)|1-(v%1) otherwise

</member>
        <member name="F:aiTextureMapMode_Decal">
If the texture coordinates for a pixel are outside [0...1]
	 *  the texture is not applied to that pixel

</member>
        <member name="F:aiTextureMapMode_Clamp">
Texture coordinates outside [0...1]
     *  are clamped to the nearest valid value.

</member>
        <member name="F:aiTextureMapMode_Wrap">
A texture coordinate u|v is translated to u%1|v%1 

</member>
        <member name="F:_aiTextureOp_Force32Bit">
@cond never 
	 *  This value is not used. It forces the compiler to use at least
	 *  32 Bit integers to represent this enum.

</member>
        <member name="F:aiTextureOp_SignedAdd">
T = T1 + (T2-0.5) 
</member>
        <member name="F:aiTextureOp_SmoothAdd">
T = (T1 + T2) - (T1 * T2) 
</member>
        <member name="F:aiTextureOp_Divide">
T = T1 / T2 
</member>
        <member name="F:aiTextureOp_Subtract">
T = T1 - T2 
</member>
        <member name="F:aiTextureOp_Add">
T = T1 + T2 
</member>
        <member name="F:aiTextureOp_Multiply">
T = T1 * T2 
</member>
        <member name="M:aiCamera.GetCameraMatrix(aiMatrix4x4t&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief Get a *right-handed* camera matrix from me
	 *  @param out Camera matrix to be filled

</member>
        <member name="F:aiCamera.mAspect">
Screen aspect ratio.
	 *
	 * This is the ration between the width and the height of the
	 * screen. Typical values are 4/3, 1/2 or 1/1. This value is
	 * 0 if the aspect ratio is not defined in the source file.
	 * 0 is also the default value.

</member>
        <member name="F:aiCamera.mClipPlaneFar">
Distance of the far clipping plane from the camera.
	 *
	 * The far clipping plane must, of course, be further away than the
	 * near clipping plane. The default value is 1000.f. The ratio
	 * between the near and the far plane should not be too
	 * large (between 1000-10000 should be ok) to avoid floating-point
	 * inaccuracies which could lead to z-fighting.

</member>
        <member name="F:aiCamera.mClipPlaneNear">
Distance of the near clipping plane from the camera.
	 *
	 * The value may not be 0.f (for arithmetic reasons to prevent
	 * a division through zero). The default value is 0.1f.

</member>
        <member name="F:aiCamera.mHorizontalFOV">
Half horizontal field of view angle, in radians. 
	 *
	 *  The field of view angle is the angle between the center
	 *  line of the screen and the left or right border.
	 *  The default value is 1/4PI.

</member>
        <member name="F:aiCamera.mLookAt">
'LookAt' - vector of the camera coordinate system relative to
	 *  the coordinate space defined by the corresponding node.
	 *
	 *  This is the viewing direction of the user.
	 *  The default value is 0|0|1. The vector
	 *  may be normalized, but it needn't.

</member>
        <member name="F:aiCamera.mUp">
'Up' - vector of the camera coordinate system relative to
	 *  the coordinate space defined by the corresponding node.
	 *
	 *  The 'right' vector of the camera coordinate system is
	 *  the cross product of  the up and lookAt vectors.
	 *  The default value is 0|1|0. The vector
	 *  may be normalized, but it needn't.

</member>
        <member name="F:aiCamera.mPosition">
Position of the camera relative to the coordinate space
	 *  defined by the corresponding node.
	 *
	 *  The default value is 0|0|0.

</member>
        <member name="F:aiCamera.mName">
The name of the camera.
	 *
	 *  There must be a node in the scenegraph with the same name.
	 *  This node specifies the position of the camera in the scene
	 *  hierarchy and can be animated.

</member>
        <member name="F:aiLight.mAngleOuterCone">
Outer angle of a spot light's light cone.
	 *
	 *  The spot light does not affect objects outside this angle.
	 *  The angle is given in radians. It is 2PI for point lights and 
	 *  undefined for directional lights. The outer angle must be
	 *  greater than or equal to the inner angle.
	 *  It is assumed that the application uses a smooth
	 *  interpolation between the inner and the outer cone of the
	 *  spot light. 

</member>
        <member name="F:aiLight.mAngleInnerCone">
Inner angle of a spot light's light cone.
	 *
	 *  The spot light has maximum influence on objects inside this
	 *  angle. The angle is given in radians. It is 2PI for point 
	 *  lights and undefined for directional lights.

</member>
        <member name="F:aiLight.mColorAmbient">
Ambient color of the light source
	 *
	 *  The ambient light color is multiplied with the ambient
	 *  material color to obtain the final color that contributes
	 *  to the ambient shading term. Most renderers will ignore
	 *  this value it, is just a remaining of the fixed-function pipeline
	 *  that is still supported by quite many file formats.

</member>
        <member name="F:aiLight.mColorSpecular">
Specular color of the light source
	 *
	 *  The specular light color is multiplied with the specular
	 *  material color to obtain the final color that contributes
	 *  to the specular shading term.

</member>
        <member name="F:aiLight.mColorDiffuse">
Diffuse color of the light source
	 *
	 *  The diffuse light color is multiplied with the diffuse 
	 *  material color to obtain the final color that contributes
	 *  to the diffuse shading term.

</member>
        <member name="F:aiLight.mAttenuationQuadratic">
Quadratic light attenuation factor. 
	 *  
	 *  The intensity of the light source at a given distance 'd' from
	 *  the light's position is
	 *  @code
	 *  Atten = 1/( att0 + att1 * d + att2 * d*d)
	 *  @endcode
	 *  This member corresponds to the att2 variable in the equation.
	 *  Naturally undefined for directional lights.

</member>
        <member name="F:aiLight.mAttenuationLinear">
Linear light attenuation factor. 
	 *
	 *  The intensity of the light source at a given distance 'd' from
	 *  the light's position is
	 *  @code
	 *  Atten = 1/( att0 + att1 * d + att2 * d*d)
	 *  @endcode
	 *  This member corresponds to the att1 variable in the equation.
	 *  Naturally undefined for directional lights.

</member>
        <member name="F:aiLight.mAttenuationConstant">
Constant light attenuation factor. 
	 *
	 *  The intensity of the light source at a given distance 'd' from
	 *  the light's position is
	 *  @code
	 *  Atten = 1/( att0 + att1 * d + att2 * d*d)
	 *  @endcode
	 *  This member corresponds to the att0 variable in the equation.
	 *  Naturally undefined for directional lights.

</member>
        <member name="F:aiLight.mDirection">
Direction of the light source in space. Relative to the
	 *  transformation of the node corresponding to the light.
	 *
	 *  The direction is undefined for point lights. The vector
	 *  may be normalized, but it needn't.

</member>
        <member name="F:aiLight.mPosition">
Position of the light source in space. Relative to the
	 *  transformation of the node corresponding to the light.
	 *
	 *  The position is undefined for directional lights.

</member>
        <member name="F:aiLight.mType">
The type of the light source.
 	 *
	 * aiLightSource_UNDEFINED is not a valid value for this member.

</member>
        <member name="F:aiLight.mName">
The name of the light source.
	 *
	 *  There must be a node in the scenegraph with the same name.
	 *  This node specifies the position of the light in the scene
	 *  hierarchy and can be animated.

</member>
        <member name="T:aiLightSourceType">
@file light.h
 *  @brief Defines the aiLight data structure

Enumerates all supported types of light sources.

</member>
        <member name="F:_aiLightSource_Force32Bit">
This value is not used. It is just there to force the
	 *  compiler to map this enum to a 32 Bit integer.

</member>
        <member name="F:aiMesh.mAnimMeshes">
NOT CURRENTLY IN USE. Attachment meshes for this mesh, for vertex-based animation. 
	 *  Attachment meshes carry replacement data for some of the
	 *  mesh'es vertex components (usually positions, normals). 
</member>
        <member name="F:aiMesh.mNumAnimMeshes">
NOT CURRENTLY IN USE. The number of attachment meshes 
</member>
        <member name="F:aiMesh.mName">
Name of the mesh. Meshes can be named, but this is not a
	 *  requirement and leaving this field empty is totally fine.
	 *  There are mainly three uses for mesh names: 
	 *   - some formats name nodes and meshes independently.
	 *   - importers tend to split meshes up to meet the
	 *      one-material-per-mesh requirement. Assigning
	 *      the same (dummy) name to each of the result meshes
	 *      aids the caller at recovering the original mesh
	 *      partitioning.
	 *   - Vertex animations refer to meshes by their names.
	 *
</member>
        <member name="F:aiMesh.mMaterialIndex">
The material used by this mesh. 
	 * A mesh does use only a single material. If an imported model uses
	 * multiple materials, the import splits up the mesh. Use this value 
	 * as index into the scene's material list.

</member>
        <member name="F:aiMesh.mBones">
The bones of this mesh. 
	* A bone consists of a name by which it can be found in the
	* frame hierarchy and a set of vertex weights.

</member>
        <member name="F:aiMesh.mNumBones">
The number of bones this mesh contains. 
	* Can be 0, in which case the mBones array is NULL. 

</member>
        <member name="F:aiMesh.mFaces">
The faces the mesh is constructed from. 
	* Each face refers to a number of vertices by their indices. 
	* This array is always present in a mesh, its size is given 
	* in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT
	* is NOT set each face references an unique set of vertices.

</member>
        <member name="F:aiMesh.mNumUVComponents">
Specifies the number of components for a given UV channel.
	* Up to three channels are supported (UVW, for accessing volume
	* or cube maps). If the value is 2 for a given channel n, the
	* component p.z of mTextureCoords[n][p] is set to 0.0f.
	* If the value is 1 for a given channel, p.y is set to 0.0f, too.
	* @note 4D coords are not supported 

</member>
        <member name="F:aiMesh.mTextureCoords">
Vertex texture coords, also known as UV channels.
	* A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS per
	* vertex. NULL if not present. The array is mNumVertices in size. 

</member>
        <member name="F:aiMesh.mColors">
Vertex color sets. 
	* A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex 
	* colors per vertex. NULL if not present. Each array is
	* mNumVertices in size if present.

</member>
        <member name="F:aiMesh.mBitangents">
Vertex bitangents. 
	* The bitangent of a vertex points in the direction of the positive 
	* Y texture axis. The array contains normalized vectors, NULL if not
	* present. The array is mNumVertices in size. 
	* @note If the mesh contains tangents, it automatically also contains
	* bitangents.  

</member>
        <member name="F:aiMesh.mTangents">
Vertex tangents. 
	* The tangent of a vertex points in the direction of the positive 
	* X texture axis. The array contains normalized vectors, NULL if
	* not present. The array is mNumVertices in size. A mesh consisting 
	* of points and lines only may not have normal vectors. Meshes with 
	* mixed primitive types (i.e. lines and triangles) may have 
	* normals, but the normals for vertices that are only referenced by
	* point or line primitives are undefined and set to qNaN.  See
	* the #mNormals member for a detailled discussion of qNaNs.
	* @note If the mesh contains tangents, it automatically also 
	* contains bitangents.

</member>
        <member name="F:aiMesh.mNormals">
Vertex normals. 
	* The array contains normalized vectors, NULL if not present. 
	* The array is mNumVertices in size. Normals are undefined for
	* point and line primitives. A mesh consisting of points and
	* lines only may not have normal vectors. Meshes with mixed
	* primitive types (i.e. lines and triangles) may have normals,
	* but the normals for vertices that are only referenced by
	* point or line primitives are undefined and set to QNaN (WARN:
	* qNaN compares to inequal to *everything*, even to qNaN itself.
	* Using code like this to check whether a field is qnan is:
	* @code
	* #define IS_QNAN(f) (f != f)
	* @endcode
	* still dangerous because even 1.f == 1.f could evaluate to false! (
	* remember the subtleties of IEEE754 artithmetics). Use stuff like
	* @c fpclassify instead.
	* @note Normal vectors computed by Assimp are always unit-length.
	* However, this needn't apply for normals that have been taken
	*   directly from the model file.

</member>
        <member name="F:aiMesh.mVertices">
Vertex positions. 
	* This array is always present in a mesh. The array is 
	* mNumVertices in size. 

</member>
        <member name="F:aiMesh.mNumFaces">
The number of primitives (triangles, polygons, lines) in this  mesh. 
	* This is also the size of the mFaces array.
	* The maximum value for this member is #AI_MAX_FACES.

</member>
        <member name="F:aiMesh.mNumVertices">
The number of vertices in this mesh. 
	* This is also the size of all of the per-vertex data arrays.
	* The maximum value for this member is #AI_MAX_VERTICES.

</member>
        <member name="F:aiMesh.mPrimitiveTypes">
Bitwise combination of the members of the #aiPrimitiveType enum.
	 * This specifies which types of primitives are present in the mesh.
	 * The "SortByPrimitiveType"-Step can be used to make sure the 
	 * output meshes consist of one primitive type each.

</member>
        <member name="T:aiMesh">
@brief A mesh represents a geometry or model with a single material. 
*
* It usually consists of a number of vertices and a series of primitives/faces 
* referencing the vertices. In addition there might be a series of bones, each 
* of them addressing a number of vertices with a certain weight. Vertex data 
* is presented in channels with each channel containing a single per-vertex 
* information such as a set of texture coords or a normal vector.
* If a data pointer is non-null, the corresponding data stream is present.
* From C++-programs you can also use the comfort functions Has*() to
* test for the presence of various data streams.
*
* A Mesh uses only a single material which is referenced by a material ID.
* @note The mPositions member is usually not optional. However, vertex positions 
* *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in 
* @code
* aiScene::mFlags
* @endcode

</member>
        <member name="M:aiAnimMesh.HasTangentsAndBitangents">
Check whether the anim mesh overrides the vertex tangents
	 *  and bitangents of its host mesh. As for aiMesh,
	 *  tangents and bitangents always go together. 
</member>
        <member name="M:aiAnimMesh.HasNormals">
Check whether the anim mesh overrides the vertex normals
	 *  of its host mesh
</member>
        <member name="M:aiAnimMesh.HasPositions">
Check whether the anim mesh overrides the vertex positions 
	 *  of its host mesh
</member>
        <member name="F:aiAnimMesh.mNumVertices">
The number of vertices in the aiAnimMesh, and thus the length of all
	 * the member arrays.
	 *
	 * This has always the same value as the mNumVertices property in the
	 * corresponding aiMesh. It is duplicated here merely to make the length
	 * of the member arrays accessible even if the aiMesh is not known, e.g.
	 * from language bindings.

</member>
        <member name="F:aiAnimMesh.mTextureCoords">
Replacement for aiMesh::mTextureCoords 
</member>
        <member name="F:aiAnimMesh.mColors">
Replacement for aiMesh::mColors 
</member>
        <member name="F:aiAnimMesh.mBitangents">
Replacement for aiMesh::mBitangents. 
</member>
        <member name="F:aiAnimMesh.mTangents">
Replacement for aiMesh::mTangents. 
</member>
        <member name="F:aiAnimMesh.mNormals">
Replacement for aiMesh::mNormals.  
</member>
        <member name="F:aiAnimMesh.mVertices">
Replacement for aiMesh::mVertices. If this array is non-NULL, 
	 *  it *must* contain mNumVertices entries. The corresponding
	 *  array in the host mesh must be non-NULL as well - animation
	 *  meshes may neither add or nor remove vertex components (if
	 *  a replacement array is NULL and the corresponding source
	 *  array is not, the source data is taken instead)
</member>
        <member name="T:aiAnimMesh">
@brief NOT CURRENTLY IN USE. An AnimMesh is an attachment to an #aiMesh stores per-vertex 
 *  animations for a particular frame.
 *  
 *  You may think of an #aiAnimMesh as a `patch` for the host mesh, which
 *  replaces only certain vertex data streams at a particular time. 
 *  Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).
 *  The actual relationship between the time line and anim meshes is 
 *  established by #aiMeshAnim, which references singular mesh attachments
 *  by their ID and binds them to a time offset.

</member>
        <member name="T:aiPrimitiveType">
@brief Enumerates the types of geometric primitives supported by Assimp.
 *  
 *  @see aiFace Face data structure
 *  @see aiProcess_SortByPType Per-primitive sorting of meshes
 *  @see aiProcess_Triangulate Automatic triangulation
 *  @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.

</member>
        <member name="F:_aiPrimitiveType_Force32Bit">
This value is not used. It is just here to force the
	 *  compiler to map this enum to a 32 Bit integer.

</member>
        <member name="F:aiPrimitiveType_POLYGON">
A higher-level polygon with more than 3 edges.
	 *
	 * A triangle is a polygon, but polygon in this context means
	 * "all polygons that are not triangles". The "Triangulate"-Step
	 * is provided for your convenience, it splits all polygons in
	 * triangles (which are much easier to handle).

</member>
        <member name="F:aiPrimitiveType_TRIANGLE">
A triangular primitive. 
	 *
	 * A triangle consists of three indices.

</member>
        <member name="F:aiPrimitiveType_LINE">
A line primitive. 
	 *
	 * This is a line defined through a start and an end position.
	 * #aiFace contains exactly two indices for such a primitive.

</member>
        <member name="F:aiPrimitiveType_POINT">
A point primitive. 
	 *
	 * This is just a single vertex in the virtual world, 
	 * #aiFace contains just one index for such a primitive.

</member>
        <member name="T:aiBone">
@brief A single bone of a mesh.
 *
 *  A bone has a name by which it can be found in the frame hierarchy and by
 *  which it can be addressed by animations. In addition it has a number of 
 *  influences on vertices.

</member>
        <member name="T:aiVertexWeight">
@brief A single influence of a bone on a vertex.

</member>
        <member name="F:aiTexture.pcData">
Data of the texture.
	 *
	 * Points to an array of mWidth * mHeight aiTexel's.
	 * The format of the texture data is always ARGB8888 to
	 * make the implementation for user of the library as easy
	 * as possible. If mHeight = 0 this is a pointer to a memory
	 * buffer of size mWidth containing the compressed texture
	 * data. Good luck, have fun!

</member>
        <member name="F:aiTexture.achFormatHint">
A hint from the loader to make it easier for applications
	 *  to determine the type of embedded compressed textures.
	 *
	 * If mHeight != 0 this member is undefined. Otherwise it
	 * is set set to '\\0\\0\\0\\0' if the loader has no additional
	 * information about the texture file format used OR the
	 * file extension of the format without a trailing dot. If there 
	 * are multiple file extensions for a format, the shortest 
	 * extension is chosen (JPEG maps to 'jpg', not to 'jpeg').
	 * E.g. 'dds\\0', 'pcx\\0', 'jpg\\0'.  All characters are lower-case.
	 * The fourth character will always be '\\0'.

</member>
        <member name="F:aiTexture.mHeight">
Height of the texture, in pixels
	 *
	 * If this value is zero, pcData points to an compressed texture
	 * in any format (e.g. JPEG).

</member>
        <member name="F:aiTexture.mWidth">
Width of the texture, in pixels
	 *
	 * If mHeight is zero the texture is compressed in a format
	 * like JPEG. In this case mWidth specifies the size of the
	 * memory area pcData is pointing to, in bytes.

</member>
        <member name="T:aiTexture">
Helper structure to describe an embedded texture
 * 
 * Normally textures are contained in external files but some file formats embed
 * them directly in the model file. There are two types of embedded textures: 
 * 1. Uncompressed textures. The color data is given in an uncompressed format. 
 * 2. Compressed textures stored in a file format like png or jpg. The raw file 
 * bytes are given so the application must utilize an image decoder (e.g. DevIL) to
 * get access to the actual color data.

</member>
        <member name="T:aiTexel">
@file texture.h
 *  @brief Defines texture helper structures for the library
 *
 * Used for file formats which embed their textures into the model file.
 * Supported are both normal textures, which are stored as uncompressed
 * pixels, and "compressed" textures, which are stored in a file format
 * such as PNG or TGA.

@def AI_MAKE_EMBEDDED_TEXNAME
 *  Used to build the reserved path name used by the material system to 
 *  reference textures that are embedded into their corresponding
 *  model files. The parameter specifies the index of the texture
 *  (zero-based, in the aiScene::mTextures array)

@brief Helper structure to represent a texel in a ARGB8888 format
* 
*  Used by aiTexture.

</member>
        <member name="F:_aiComponent_Force32Bit">
This value is not used. It is just there to force the
	 *  compiler to map this enum to a 32 Bit integer. 
</member>
        <member name="F:aiComponent_MATERIALS">
Removes all materials. One default material will
	 * be generated, so aiScene::mNumMaterials will be 1. 
</member>
        <member name="F:aiComponent_MESHES">
Removes all meshes (aiScene::mMeshes). 
</member>
        <member name="F:aiComponent_CAMERAS">
Removes all light sources (aiScene::mCameras).
	 * The corresponding scenegraph nodes are NOT removed.
	 * use the #aiProcess_OptimizeGraph step to do this 
</member>
        <member name="F:aiComponent_LIGHTS">
Removes all light sources (aiScene::mLights).
	 * The corresponding scenegraph nodes are NOT removed.
	 * use the #aiProcess_OptimizeGraph step to do this 
</member>
        <member name="F:aiComponent_TEXTURES">
Removes all embedded textures (aiScene::mTextures) 
</member>
        <member name="F:aiComponent_ANIMATIONS">
Removes all node animations (aiScene::mAnimations).
	 * The corresponding scenegraph nodes are NOT removed.
	 * use the #aiProcess_OptimizeGraph step to do this 
</member>
        <member name="F:aiComponent_BONEWEIGHTS">
Removes all bone weights from all meshes.
	 * The scenegraph nodes corresponding to the bones are NOT removed.
	 * use the #aiProcess_OptimizeGraph step to do this 
</member>
        <member name="F:aiComponent_TEXCOORDS">
ALL texture UV sets
	 * aiComponent_TEXCOORDn(N) to specify the N'th set  
</member>
        <member name="F:aiComponent_COLORS">
ALL color sets
	 * Use aiComponent_COLORn(N) to specify the N'th set 
</member>
        <member name="F:aiComponent_TANGENTS_AND_BITANGENTS">
Tangents and bitangents go always together ... 
</member>
        <member name="F:aiComponent_NORMALS">
Normal vectors 
</member>
        <member name="F:aiMemoryInfo.total">
Total storage allocated for the full import. 
</member>
        <member name="F:aiMemoryInfo.lights">
Storage allocated for light data 
</member>
        <member name="F:aiMemoryInfo.cameras">
Storage allocated for camera data 
</member>
        <member name="F:aiMemoryInfo.animations">
Storage allocated for animation data 
</member>
        <member name="F:aiMemoryInfo.nodes">
Storage allocated for node data 
</member>
        <member name="F:aiMemoryInfo.meshes">
Storage allocated for mesh data 
</member>
        <member name="F:aiMemoryInfo.materials">
Storage allocated for material data  
</member>
        <member name="F:aiMemoryInfo.textures">
Storage allocated for texture data 
</member>
        <member name="M:aiMemoryInfo.#ctor">
Default constructor 
</member>
        <member name="T:aiMemoryInfo">
Stores the memory requirements for different components (e.g. meshes, materials,
 *  animations) of an import. All sizes are in bytes.
 *  @see Importer::GetMemoryRequirements()

</member>
        <member name="T:aiDefaultLogStream">
@brief Enumerates predefined log streaming destinations. 
 *  Logging to these streams can be enabled with a single call to 
 *   #LogStream::createDefaultStream or #aiAttachPredefinedLogStream(),
 *   respectively.

</member>
        <member name="F:_AI_DLS_ENFORCE_ENUM_SIZE">
@cond never 
	 *  Force 32-bit size enum 

</member>
        <member name="F:aiDefaultLogStream_DEBUGGER">
MSVC only: Stream the log the the debugger
	 * (this relies on OutputDebugString from the Win32 SDK)

</member>
        <member name="F:aiDefaultLogStream_STDERR">
Stream the log to std::cerr 
</member>
        <member name="F:aiDefaultLogStream_STDOUT">
Stream the log to std::cout 
</member>
        <member name="F:aiDefaultLogStream_FILE">
Stream the log to a file 
</member>
        <member name="T:aiOrigin">
Seek origins (for the virtual file system API).
 *  Much cooler than using SEEK_SET, SEEK_CUR or SEEK_END.

</member>
        <member name="F:_AI_ORIGIN_ENFORCE_ENUM_SIZE">
 @cond never 
	 *   Force 32-bit size enum 

</member>
        <member name="F:aiOrigin_END">
End of the file, offsets must be negative 
</member>
        <member name="F:aiOrigin_CUR">
Current position of the file pointer 
</member>
        <member name="F:aiOrigin_SET">
Beginning of the file 
</member>
        <member name="T:aiReturn">
Standard return type for some library functions.
 * Rarely used, and if, mostly in the C API.

</member>
        <member name="F:_AI_ENFORCE_ENUM_SIZE">
@cond never 
	 *  Force 32-bit size enum

</member>
        <member name="F:aiReturn_OUTOFMEMORY">
Indicates that not enough memory was available
	 * to perform the requested operation 

</member>
        <member name="F:aiReturn_FAILURE">
Indicates that a function failed 
</member>
        <member name="F:aiReturn_SUCCESS">
Indicates that a function was successful 
</member>
        <member name="F:aiString.data">
String buffer. Size limit is MAXLEN 
</member>
        <member name="F:aiString.length">
Binary length of the string excluding the terminal 0. This is NOT the 
	 *  logical length of strings containing UTF-8 multibyte sequences! It's
	 *  the number of bytes from the beginning of the string to its end.
</member>
        <member name="M:aiString.C_Str">
Returns a pointer to the underlying zero-terminated array of characters 
</member>
        <member name="M:aiString.Clear">
Clear the string - reset its length to zero 
</member>
        <member name="M:aiString.Append(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Append a string to the string 
</member>
        <member name="M:aiString.op_Inequality(aiString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inverse comparison operator 
</member>
        <member name="M:aiString.op_Equality(aiString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Comparison operator 
</member>
        <member name="M:aiString.op_Assign(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assign a cstd::string to the string 
</member>
        <member name="M:aiString.op_Assign(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Assign a const char* to the string 
</member>
        <member name="M:aiString.Set(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Copy a const char* to the aiString 
</member>
        <member name="M:aiString.Set(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy a std::string to the aiString 
</member>
        <member name="M:aiString.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor from std::string 
</member>
        <member name="M:aiString.#ctor(aiString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor 
</member>
        <member name="M:aiString.#ctor">
Default constructor, the string is set to have zero length 
</member>
        <member name="T:aiString">
Represents an UTF-8 string, zero byte terminated.
 *
 *  The character set of an aiString is explicitly defined to be UTF-8. This Unicode
 *  transformation was chosen in the belief that most strings in 3d files are limited
 *  to ASCII, thus the character set needed to be strictly ASCII compatible.
 *  
 *  Most text file loaders provide proper Unicode input file handling, special unicode
 *  characters are correctly transcoded to UTF8 and are kept throughout the libraries'
 *  import pipeline. 
 *
 *  For most applications, it will be absolutely sufficient to interpret the
 *  aiString as ASCII data and work with it as one would work with a plain char*. 
 *  Windows users in need of proper support for i.e asian characters can use the
 *  #MultiByteToWideChar(), #WideCharToMultiByte() WinAPI functionality to convert the
 *  UTF-8 strings to their working character set (i.e. MBCS, WideChar).
 *
 *  We use this representation instead of std::string to be C-compatible. The 
 *  (binary) length of such a string is limited to MAXLEN characters (including the
 *  the terminating zero).

</member>
        <member name="M:aiColor3D.IsBlack">
Check whether a color is black 
</member>
        <member name="M:aiColor3D.op_Subscript(System.UInt32)">
Access a specific color component 

Access a specific color component 
</member>
        <member name="M:aiColor3D.op_Multiply(System.Single)">
Multiply with a scalar 
</member>
        <member name="M:aiColor3D.op_Multiply(aiColor3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Component-wise multiplication 
</member>
        <member name="M:aiColor3D.op_Subtraction(aiColor3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Component-wise subtraction 
</member>
        <member name="M:aiColor3D.op_Addition(aiColor3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Component-wise addition 
</member>
        <member name="M:aiColor3D.op_Inequality(aiColor3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Component-wise inverse comparison 
</member>
        <member name="M:aiColor3D.op_Equality(aiColor3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Component-wise comparison 
</member>
        <member name="T:aiColor3D">
Represents a color in Red-Green-Blue space. 

</member>
        <member name="T:aiRay">
Represents a ray

</member>
        <member name="T:aiPlane">
Represents a plane in a three-dimensional, euclidean space

</member>
        <member name="T:Assimp.Intern.AllocateFromAssimpHeap">
@brief Internal helper class to utilize our internal new/delete 
	 *    routines for allocating object of this and derived classes.
	 *
	 * By doing this you can safely share class objects between Assimp
	 * and the application - it works even over DLL boundaries. A good
	 * example is the #IOSystem where the application allocates its custom
	 * #IOSystem, then calls #Importer::SetIOSystem(). When the Importer
	 * destructs, Assimp calls operator delete on the stored #IOSystem.
	 * If it lies on a different heap than Assimp is working with,
	 * the application is determined to crash.

</member>
        <member name="M:glm_i128_interleave(__m128i)">
@ref core
@file glm/detail/func_integer_simd.inl
@ref simd
@file glm/simd/integer.h
</member>
        <member name="F:_InterlockedAnd(System.Int32!System.Runtime.CompilerServices.IsLong|System.Runtime.CompilerServices.IsVolatile*,System.Int32!System.Runtime.CompilerServices.IsLong)">
@ref core
@file glm/detail/func_integer.inl
</member>
        <member name="M:glm.unpackHalf2x16(System.UInt32)">
Returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, 
interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, 
and converting them to 32-bit floating-point values.
The first component of the vector is obtained from the 16 least-significant bits of v; 
the second component is obtained from the 16 most-significant bits of v.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackHalf2x16.xml">GLSL unpackHalf2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packHalf2x16(glm.tvec2&lt;System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns an unsigned integer obtained by converting the components of a two-component floating-point vector 
to the 16-bit floating-point representation found in the OpenGL Specification, 
and then packing these two 16- bit integers into a 32-bit unsigned integer.
The first vector component specifies the 16 least-significant bits of the result; 
the second component specifies the 16 most-significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packHalf2x16.xml">GLSL packHalf2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackDouble2x32(System.Double)">
Returns a two-component unsigned integer vector representation of v. 
The bit-level representation of v is preserved. 
The first component of the vector contains the 32 least significant bits of the double; 
the second component consists the 32 most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackDouble2x32.xml">GLSL unpackDouble2x32 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packDouble2x32(glm.tvec2&lt;System.UInt32,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a double-precision value obtained by packing the components of v into a 64-bit value. 
If an IEEE 754 Inf or NaN is created, it will not signal, and the resulting floating point value is unspecified. 
Otherwise, the bit- level representation of v is preserved. 
The first vector component specifies the 32 least significant bits; 
the second component specifies the 32 most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packDouble2x32.xml">GLSL packDouble2x32 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackSnorm4x8(System.UInt32)">
First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers. 
Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value f to floating point is done as follows:
unpackSnorm4x8: clamp(f / 127.0, -1, +1)

The first component of the returned vector will be extracted from the least significant bits of the input; 
the last component will be extracted from the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm4x8.xml">GLSL unpackSnorm4x8 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackUnorm4x8(System.UInt32)">
First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers. 
Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value f to floating point is done as follows:
unpackUnorm4x8: f / 255.0

The first component of the returned vector will be extracted from the least significant bits of the input; 
the last component will be extracted from the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm4x8.xml">GLSL unpackUnorm4x8 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackSnorm2x16(System.UInt32)">
First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers. 
Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value f to floating point is done as follows:
unpackSnorm2x16: clamp(f / 32767.0, -1, +1)

The first component of the returned vector will be extracted from the least significant bits of the input; 
the last component will be extracted from the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm2x16.xml">GLSL unpackSnorm2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.unpackUnorm2x16(System.UInt32)">
First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit signed integers. 
Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.

The conversion for unpacked fixed-point value f to floating point is done as follows:
unpackUnorm2x16: f / 65535.0 

The first component of the returned vector will be extracted from the least significant bits of the input; 
the last component will be extracted from the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm2x16.xml">GLSL unpackUnorm2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packSnorm4x8(glm.tvec4&lt;System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values. 
Then, the results are packed into the returned 32-bit unsigned integer.

The conversion for component c of v to fixed point is done as follows:
packSnorm4x8:	round(clamp(c, -1, +1) * 127.0) 

The first component of the vector will be written to the least significant bits of the output; 
the last component will be written to the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm4x8.xml">GLSL packSnorm4x8 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packUnorm4x8(glm.tvec4&lt;System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values. 
Then, the results are packed into the returned 32-bit unsigned integer.

The conversion for component c of v to fixed point is done as follows:
packUnorm4x8:	round(clamp(c, 0, +1) * 255.0)

The first component of the vector will be written to the least significant bits of the output; 
the last component will be written to the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm4x8.xml">GLSL packUnorm4x8 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packSnorm2x16(glm.tvec2&lt;System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values. 
Then, the results are packed into the returned 32-bit unsigned integer.

The conversion for component c of v to fixed point is done as follows:
packSnorm2x16: round(clamp(v, -1, +1) * 32767.0)

The first component of the vector will be written to the least significant bits of the output; 
the last component will be written to the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm2x16.xml">GLSL packSnorm2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm.packUnorm2x16(glm.tvec2&lt;System.Single,0x0&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@addtogroup core_func_packing
@{
First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values. 
Then, the results are packed into the returned 32-bit unsigned integer.

The conversion for component c of v to fixed point is done as follows:
packUnorm2x16: round(clamp(c, 0, +1) * 65535.0) 

The first component of the vector will be written to the least significant bits of the output; 
the last component will be written to the most significant bits.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm2x16.xml">GLSL packUnorm2x16 man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a></member>
        <member name="M:glm_mat4_matrixCompMult(__m128!System.Runtime.CompilerServices.IsConst*,__m128!System.Runtime.CompilerServices.IsConst*,__m128*)">
@ref core
@file glm/detail/func_matrix_simd.inl
@ref simd
@file glm/simd/matrix.h
</member>
        <member name="M:glm_vec4_dot(__m128,__m128)">
@ref core
@file glm/detail/func_geometric_simd.inl
@ref simd
@file glm/simd/geometric.h
</member>
        <member name="M:glm_vec4_add(__m128,__m128)">
@ref core
@file glm/detail/func_common_simd.inl
@ref simd
@file glm/simd/common.h
</member>
        <member name="M:glm.uintBitsToFloat(System.UInt32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a floating-point value corresponding to a
unsigned integer encoding of a floating-point value.
If an inf or NaN is passed in, it will not signal, and the
resulting floating point value is unspecified. Otherwise,
the bit-level representation is preserved.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/uintBitsToFloat.xml">GLSL uintBitsToFloat man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a></member>
        <member name="M:glm.intBitsToFloat(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a floating-point value corresponding to a signed
integer encoding of a floating-point value.
If an inf or NaN is passed in, it will not signal, and the
resulting floating point value is unspecified. Otherwise,
the bit-level representation is preserved.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/intBitsToFloat.xml">GLSL intBitsToFloat man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a></member>
        <member name="M:glm.floatBitsToUint(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a unsigned integer value representing
the encoding of a floating-point value. The floatingpoint
value's bit-level representation is preserved.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floatBitsToUint.xml">GLSL floatBitsToUint man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a></member>
        <member name="M:glm.floatBitsToInt(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a signed integer value representing
the encoding of a floating-point value. The floating-point
value's bit-level representation is preserved.

@see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floatBitsToInt.xml">GLSL floatBitsToInt man page</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a></member>
        <member name="M:glm_vec1_sqrt_lowp(__m128)">
@ref core
@file glm/detail/func_exponential_simd.inl
@ref simd
@file glm/simd/experimental.h
</member>
        <member name="D:glm.f64quat">
Default double-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat4">
Default double-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat3">
Default double-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat2">
Default double-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat4x4">
Default double-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat4x3">
Default double-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat4x2">
Default double-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat3x4">
Default double-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat3x3">
Default double-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat3x2">
Default double-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat2x4">
Default double-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat2x3">
Default double-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64mat2x2">
Default double-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f64vec4">
Default double-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.f64vec3">
Default double-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.f64vec2">
Default double-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.f64vec1">
Default double-precision floating-point vector of 1 components.
@see gtc_type_precision
</member>
        <member name="D:glm.f32quat">
Default single-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat4">
Default single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat3">
Default single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat2">
Default single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat4x4">
Default single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat4x3">
Default single-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat4x2">
Default single-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat3x4">
Default single-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat3x3">
Default single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat3x2">
Default single-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat2x4">
Default single-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat2x3">
Default single-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32mat2x2">
Default single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.f32vec4">
Default single-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.f32vec3">
Default single-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.f32vec2">
Default single-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.f32vec1">
Default single-precision floating-point vector of 1 components.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat4">
Default single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat3">
Default single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat2">
Default single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat4x4">
Default single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat4x3">
Default single-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat4x2">
Default single-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat3x4">
Default single-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat3x3">
Default single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat3x2">
Default single-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat2x4">
Default single-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat2x3">
Default single-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fmat2x2">
Default single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.fvec4">
Default single-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.fvec3">
Default single-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.fvec2">
Default single-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.fvec1">
Default single-precision floating-point vector of 1 components.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64quat">
High double-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32quat">
High single-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64quat">
Medium double-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32quat">
Medium single-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64quat">
Low double-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32quat">
Low single-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat4">
High double-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat3">
High double-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat2">
High double-precision floating-point 1x1 matrix.
@see gtc_type_precision
High double-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat4x4">
High double-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat4x3">
High double-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat4x2">
High double-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat3x4">
High double-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat3x3">
High double-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat3x2">
High double-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat2x4">
High double-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat2x3">
High double-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64mat2x2">
High double-precision floating-point 1x1 matrix.
@see gtc_type_precision
High double-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat4">
Medium double-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat3">
Medium double-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat2">
Medium double-precision floating-point 1x1 matrix.
@see gtc_type_precision
Medium double-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat4x4">
Medium double-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat4x3">
Medium double-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat4x2">
Medium double-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat3x4">
Medium double-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat3x3">
Medium double-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat3x2">
Medium double-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat2x4">
Medium double-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat2x3">
Medium double-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64mat2x2">
Medium double-precision floating-point 1x1 matrix.
@see gtc_type_precision
Medium double-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat4">
Low double-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat3">
Low double-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat2">
Low double-precision floating-point 1x1 matrix.
@see gtc_type_precision
Low double-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat4x4">
Low double-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat4x3">
Low double-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat4x2">
Low double-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat3x4">
Low double-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat3x3">
Low double-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat3x2">
Low double-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat2x4">
Low double-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat2x3">
Low double-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64mat2x2">
Low double-precision floating-point 1x1 matrix.
@see gtc_type_precision
Low double-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat4">
High single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat3">
High single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat2">
High single-precision floating-point 1x1 matrix.
@see gtc_type_precision
High single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat4x4">
High single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat4x3">
High single-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat4x2">
High single-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat3x4">
High single-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat3x3">
High single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat3x2">
High single-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat2x4">
High single-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat2x3">
High single-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32mat2x2">
High single-precision floating-point 1x1 matrix.
@see gtc_type_precision
High single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat4">
Medium single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat3">
Medium single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat2">
Medium single-precision floating-point 1x1 matrix.
@see gtc_type_precision
Medium single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat4x4">
Medium single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat4x3">
Medium single-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat4x2">
Medium single-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat3x4">
Medium single-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat3x3">
Medium single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat3x2">
Medium single-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat2x4">
Medium single-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat2x3">
Medium single-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32mat2x2">
High single-precision floating-point 1x1 matrix.
@see gtc_type_precision
Low single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat4">
Low single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat3">
Low single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat2">
Low single-precision floating-point 1x1 matrix.
@see gtc_type_precision
Low single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat4x4">
Low single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat4x3">
Low single-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat4x2">
Low single-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat3x4">
Low single-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat3x3">
Low single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat3x2">
Low single-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat2x4">
Low single-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat2x3">
Low single-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32mat2x2">
Low single-precision floating-point 1x1 matrix.
@see gtc_type_precision
Low single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat4">
High single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat3">
High single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat2">
High single-precision floating-point 1x1 matrix.
@see gtc_type_precision
High single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat4x4">
High single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat4x3">
High single-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat4x2">
High single-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat3x4">
High single-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat3x3">
High single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat3x2">
High single-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat2x4">
High single-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat2x3">
High single-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fmat2x2">
High single-precision floating-point 1x1 matrix.
@see gtc_type_precision
High single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat4">
Medium single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat3">
Medium single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat2">
Medium single-precision floating-point 1x1 matrix.
@see gtc_type_precision
Medium single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat4x4">
Medium single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat4x3">
Medium single-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat4x2">
Medium single-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat3x4">
Medium single-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat3x3">
Medium single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat3x2">
Medium single-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat2x4">
Medium single-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat2x3">
Medium single-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fmat2x2">
Medium single-precision floating-point 1x1 matrix.
@see gtc_type_precision
Medium single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat4">
Low single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat3">
Low single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat2">
Low single-precision floating-point 1x1 matrix.
@see gtc_type_precision
Low single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat4x4">
Low single-precision floating-point 4x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat4x3">
Low single-precision floating-point 4x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat4x2">
Low single-precision floating-point 4x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat3x4">
Low single-precision floating-point 3x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat3x3">
Low single-precision floating-point 3x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat3x2">
Low single-precision floating-point 3x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat2x4">
Low single-precision floating-point 2x4 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat2x3">
Low single-precision floating-point 2x3 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fmat2x2">
Low single-precision floating-point 1x1 matrix.
@see gtc_type_precision
Low single-precision floating-point 2x2 matrix.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64vec4">
High double-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64vec3">
High double-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64vec2">
High double-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64vec1">
High double-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64vec4">
Medium double-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64vec3">
Medium double-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64vec2">
Medium double-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64vec1">
Medium double-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64vec4">
Low double-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64vec3">
Low double-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64vec2">
Low double-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64vec1">
Low double-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32vec4">
High single-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32vec3">
High single-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32vec2">
High single-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32vec1">
High single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32vec4">
Medium single-precision floating-point vector of 4 components.
@see core_precision
</member>
        <member name="D:glm.mediump_f32vec3">
Medium single-precision floating-point vector of 3 components.
@see core_precision
</member>
        <member name="D:glm.mediump_f32vec2">
Medium single-precision floating-point vector of 2 components.
@see core_precision
</member>
        <member name="D:glm.mediump_f32vec1">
Medium single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32vec4">
Low single-precision floating-point vector of 4 components.
@see core_precision
</member>
        <member name="D:glm.lowp_f32vec3">
Low single-precision floating-point vector of 3 components.
@see core_precision
</member>
        <member name="D:glm.lowp_f32vec2">
Low single-precision floating-point vector of 2 components.
@see core_precision
</member>
        <member name="D:glm.lowp_f32vec1">
Low single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fvec4">
High Single-precision floating-point vector of 4 components.
@see core_precision
</member>
        <member name="D:glm.highp_fvec3">
High Single-precision floating-point vector of 3 components.
@see core_precision
</member>
        <member name="D:glm.highp_fvec2">
High Single-precision floating-point vector of 2 components.
@see core_precision
</member>
        <member name="D:glm.highp_fvec1">
High single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_vec1">
High single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fvec4">
Medium Single-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fvec3">
Medium Single-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fvec2">
Medium Single-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_fvec1">
Medium single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_vec1">
Medium single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fvec4">
Low single-precision floating-point vector of 4 components.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fvec3">
Low single-precision floating-point vector of 3 components.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fvec2">
Low single-precision floating-point vector of 2 components.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_fvec1">
Low single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_vec1">
Low single-precision floating-point vector of 1 component.
@see gtc_type_precision
</member>
        <member name="D:glm.f64">
Default 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.f32">
Default 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.float64_t">
Default 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.float32_t">
Default 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.float64">
Default 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.float32">
Default 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f64">
High 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_f32">
High 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_float64_t">
High 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_float32_t">
High 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_float64">
High 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_float32">
High 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f64">
Medium 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_f32">
Medium 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_float64_t">
Medium 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_float32_t">
Medium 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_float64">
Medium 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_float32">
Medium 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f64">
Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision

Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision

Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_f32">
Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision

Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision

Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_float64_t">
Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision

Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision

Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_float32_t">
Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision

Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision

Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_float64">
Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision

Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision

Low 64 bit double-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_float32">
Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision

Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision

Low 32 bit single-precision floating-point scalar.
@see gtc_type_precision
</member>
        <member name="D:glm.u64vec4">
Default precision 64 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u64vec3">
Default precision 64 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u64vec2">
Default precision 64 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u64vec1">
Default precision 64 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u64vec4">
High precision 64 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u64vec3">
High precision 64 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u64vec2">
High precision 64 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u64vec1">
High precision 64 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u64vec4">
Medium precision 64 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u64vec3">
Medium precision 64 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u64vec2">
Medium precision 64 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u64vec1">
Medium precision 64 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u64vec4">
Low precision 64 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u64vec3">
Low precision 64 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u64vec2">
Low precision 64 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u64vec1">
Low precision 64 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.u32vec4">
Default precision 32 bit unsigned integer vector of 4 components type.
@see gtc_type_precision

Default precision 32 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u32vec3">
Default precision 32 bit unsigned integer vector of 3 components type.
@see gtc_type_precision

Default precision 32 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u32vec2">
Default precision 32 bit unsigned integer vector of 2 components type.
@see gtc_type_precision

Default precision 32 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u32vec1">
Default precision 32 bit unsigned integer scalar type.
@see gtc_type_precision

Default precision 32 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u32vec4">
High precision 32 bit unsigned integer vector of 4 components type.
@see gtc_type_precision

High precision 32 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u32vec3">
High precision 32 bit unsigned integer vector of 3 components type.
@see gtc_type_precision

High precision 32 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u32vec2">
High precision 32 bit unsigned integer vector of 2 components type.
@see gtc_type_precision

High precision 32 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u32vec1">
High precision 32 bit unsigned integer scalar type.
@see gtc_type_precision

High precision 32 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u32vec4">
Medium precision 32 bit unsigned integer vector of 4 components type.
@see gtc_type_precision

Medium precision 32 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u32vec3">
Medium precision 32 bit unsigned integer vector of 3 components type.
@see gtc_type_precision

Medium precision 32 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u32vec2">
Medium precision 32 bit unsigned integer vector of 2 components type.
@see gtc_type_precision

Medium precision 32 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u32vec1">
Medium precision 32 bit unsigned integer scalar type.
@see gtc_type_precision

Medium precision 32 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u32vec4">
Low precision 32 bit unsigned integer vector of 4 components type.
@see gtc_type_precision

Low precision 32 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u32vec3">
Low precision 32 bit unsigned integer vector of 3 components type.
@see gtc_type_precision

Low precision 32 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u32vec2">
Low precision 32 bit unsigned integer vector of 2 components type.
@see gtc_type_precision

Low precision 32 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u32vec1">
Low precision 32 bit unsigned integer scalar type.
@see gtc_type_precision

Low precision 32 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.u16vec4">
Default precision 16 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u16vec3">
Default precision 16 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u16vec2">
Default precision 16 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u16vec1">
Default precision 16 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u16vec4">
High precision 16 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u16vec3">
High precision 16 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u16vec2">
High precision 16 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u16vec1">
High precision 16 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u16vec4">
Medium precision 16 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u16vec3">
Medium precision 16 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u16vec2">
Medium precision 16 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u16vec1">
Medium precision 16 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u16vec4">
Low precision 16 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u16vec3">
Low precision 16 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u16vec2">
Low precision 16 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u16vec1">
Low precision 16 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.u8vec4">
Default precision 8 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u8vec3">
Default precision 8 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u8vec2">
Default precision 8 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.u8vec1">
Default precision 8 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u8vec4">
High precision 8 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u8vec3">
High precision 8 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u8vec2">
High precision 8 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u8vec1">
High precision 8 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u8vec4">
Medium precision 8 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u8vec3">
Medium precision 8 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u8vec2">
Medium precision 8 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u8vec1">
Medium precision 8 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u8vec4">
Low precision 8 bit unsigned integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u8vec3">
Low precision 8 bit unsigned integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u8vec2">
Low precision 8 bit unsigned integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u8vec1">
Low precision 8 bit unsigned integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.u64">
64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.u32">
32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.u16">
16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.u8">
8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.uint64">
64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.uint32">
32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.uint16">
16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.uint8">
8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u64">
Medium precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u32">
Medium precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u16">
Medium precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_u8">
Medium precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_uint64_t">
Medium precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_uint32_t">
Medium precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_uint16_t">
Medium precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_uint8_t">
Medium precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_uint64">
Medium precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_uint32">
Medium precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_uint16">
Medium precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_uint8">
Medium precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u64">
Medium precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u32">
Medium precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u16">
Medium precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_u8">
Medium precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_uint64_t">
Medium precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_uint32_t">
Medium precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_uint16_t">
Medium precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_uint8_t">
Medium precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_uint64">
Medium precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_uint32">
Medium precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_uint16">
Medium precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_uint8">
Medium precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u64">
Low precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u32">
Low precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u16">
Low precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_u8">
Low precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_uint64_t">
Low precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_uint32_t">
Low precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_uint16_t">
Low precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_uint8_t">
Low precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_uint64">
Low precision 64 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_uint32">
Low precision 32 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_uint16">
Low precision 16 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_uint8">
Low precision 8 bit unsigned integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.i64vec4">
Default precision 64 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i64vec3">
Default precision 64 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i64vec2">
Default precision 64 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i64vec1">
Default precision 64 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i64vec4">
High precision 64 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i64vec3">
High precision 64 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i64vec2">
High precision 64 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i64vec1">
High precision 64 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i64vec4">
Medium precision 64 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i64vec3">
Medium precision 64 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i64vec2">
Medium precision 64 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i64vec1">
Medium precision 64 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i64vec4">
Low precision 64 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i64vec3">
Low precision 64 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i64vec2">
Low precision 64 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i64vec1">
Low precision 64 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.i32vec4">
Default precision 32 bit signed integer vector of 4 components type.
@see gtc_type_precision

Default precision 32 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i32vec3">
Default precision 32 bit signed integer vector of 3 components type.
@see gtc_type_precision

Default precision 32 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i32vec2">
Default precision 32 bit signed integer vector of 2 components type.
@see gtc_type_precision

Default precision 32 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i32vec1">
Default precision 32 bit signed integer scalar type.
@see gtc_type_precision

Default precision 32 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i32vec4">
High precision 32 bit signed integer vector of 4 components type.
@see gtc_type_precision

High precision 32 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i32vec3">
High precision 32 bit signed integer vector of 3 components type.
@see gtc_type_precision

High precision 32 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i32vec2">
High precision 32 bit signed integer vector of 2 components type.
@see gtc_type_precision

High precision 32 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i32vec1">
High precision 32 bit signed integer scalar type.
@see gtc_type_precision

High precision 32 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i32vec4">
Medium precision 32 bit signed integer vector of 4 components type.
@see gtc_type_precision

Medium precision 32 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i32vec3">
Medium precision 32 bit signed integer vector of 3 components type.
@see gtc_type_precision

Medium precision 32 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i32vec2">
Medium precision 32 bit signed integer vector of 2 components type.
@see gtc_type_precision

Medium precision 32 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i32vec1">
Medium precision 32 bit signed integer scalar type.
@see gtc_type_precision

Medium precision 32 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i32vec4">
Low precision 32 bit signed integer vector of 4 components type.
@see gtc_type_precision

Low precision 32 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i32vec3">
Low precision 32 bit signed integer vector of 3 components type.
@see gtc_type_precision

Low precision 32 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i32vec2">
Low precision 32 bit signed integer vector of 2 components type.
@see gtc_type_precision

Low precision 32 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i32vec1">
Low precision 32 bit signed integer scalar type.
@see gtc_type_precision

Low precision 32 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.i16vec4">
Default precision 16 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i16vec3">
Default precision 16 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i16vec2">
Default precision 16 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i16vec1">
Default precision 16 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i16vec4">
High precision 16 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i16vec3">
High precision 16 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i16vec2">
High precision 16 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i16vec1">
High precision 16 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i16vec4">
Medium precision 16 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i16vec3">
Medium precision 16 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i16vec2">
Medium precision 16 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i16vec1">
Medium precision 16 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i16vec4">
Low precision 16 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i16vec3">
Low precision 16 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i16vec2">
Low precision 16 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i16vec1">
Low precision 16 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.i8vec4">
Default precision 8 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i8vec3">
Default precision 8 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i8vec2">
Default precision 8 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.i8vec1">
Default precision 8 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i8vec4">
High precision 8 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i8vec3">
High precision 8 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i8vec2">
High precision 8 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i8vec1">
High precision 8 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i8vec4">
Medium precision 8 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i8vec3">
Medium precision 8 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i8vec2">
Medium precision 8 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i8vec1">
Medium precision 8 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i8vec4">
Low precision 8 bit signed integer vector of 4 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i8vec3">
Low precision 8 bit signed integer vector of 3 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i8vec2">
Low precision 8 bit signed integer vector of 2 components type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i8vec1">
Low precision 8 bit signed integer scalar type.
@see gtc_type_precision
</member>
        <member name="D:glm.i64">
64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.i32">
32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.i16">
16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.i8">
8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.int64">
64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.int32">
32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.int16">
16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.int8">
8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i64">
High precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i32">
High precision 32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i16">
High precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_i8">
High precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_int64_t">
High precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_int32_t">
32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_int16_t">
High precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_int8_t">
High precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_int64">
High precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_int32">
High precision 32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_int16">
High precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_int8">
High precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i64">
Medium precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i32">
Medium precision 32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i16">
Medium precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_i8">
Medium precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_int64_t">
Medium precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_int32_t">
Medium precision 32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_int16_t">
Medium precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_int8_t">
Medium precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_int64">
Medium precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_int32">
Medium precision 32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_int16">
Medium precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.mediump_int8">
Medium precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i64">
Low precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i32">
Low precision 32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i16">
Low precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_i8">
Low precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_int64_t">
Low precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_int32_t">
Low precision 32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_int16_t">
Low precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_int8_t">
Low precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_int64">
Low precision 64 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_int32">
Low precision 32 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_int16">
Low precision 16 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.lowp_int8">
Low precision 8 bit signed integer type.
@see gtc_type_precision
</member>
        <member name="D:glm.dquat">
Quaternion of default double-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.highp_dquat">
Quaternion of high double-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.mediump_dquat">
Quaternion of medium double-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.lowp_dquat">
Quaternion of low double-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.fquat">
Quaternion of default single-precision floating-point numbers.

@see gtc_quaternion

Default single-precision floating-point quaternion.
@see gtc_type_precision
</member>
        <member name="D:glm.highp_fquat">
Quaternion of high single-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.mediump_fquat">
Quaternion of medium single-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.lowp_fquat">
Quaternion of low single-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.quat">
Quaternion of default single-precision floating-point numbers.
</member>
        <member name="D:glm.highp_quat">
Quaternion of high single-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.mediump_quat">
Quaternion of medium single-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.lowp_quat">
Quaternion of low single-precision floating-point numbers.

@see gtc_quaternion
</member>
        <member name="D:glm.dmat4x4">
4 * 4 matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat4x3">
4 * 3 matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat4x2">
4 * 2 matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat3x4">
3 * 4 matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat3x3">
3 * 3 matrix of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat3x2">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat2x4">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat2x3">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat2x2">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat4">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat3">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.dmat2">
@}

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_dmat4x4">
4 columns of 4 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat4x4">
4 columns of 4 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat4x4">
4 columns of 4 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat4">
4 columns of 4 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat4">
4 columns of 4 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat4">
@}
@addtogroup core_precision
@{
4 columns of 4 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat4x3">
4 columns of 3 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat4x3">
4 columns of 3 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat4x3">
@}
@addtogroup core_precision
@{
4 columns of 3 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat4x2">
4 columns of 2 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat4x2">
4 columns of 2 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat4x2">
@}
@addtogroup core_precision
@{
4 columns of 2 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat3x4">
3 columns of 4 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat3x4">
3 columns of 4 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat3x4">
@}
@addtogroup core_precision
@{
3 columns of 4 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat3x3">
3 columns of 3 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat3x3">
3 columns of 3 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat3x3">
3 columns of 3 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat3">
3 columns of 3 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat3">
3 columns of 3 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat3">
@}
@addtogroup core_precision
@{
3 columns of 3 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat3x2">
3 columns of 2 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat3x2">
3 columns of 2 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat3x2">
@}
@addtogroup core_precision
@{
3 columns of 2 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat2x4">
2 columns of 4 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat2x4">
2 columns of 4 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat2x4">
@}
@addtogroup core_precision
@{
2 columns of 4 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat2x3">
2 columns of 3 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat2x3">
2 columns of 3 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat2x3">
@}
@addtogroup core_precision
@{
2 columns of 3 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat2x2">
2 columns of 2 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat2x2">
2 columns of 2 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat2x2">
2 columns of 2 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dmat2">
2 columns of 2 components matrix of high precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dmat2">
2 columns of 2 components matrix of medium precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dmat2">
@addtogroup core_precision
@{
2 columns of 2 components matrix of low precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mat4">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat3">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat2">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat4x4">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat4x3">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat4x2">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat3x4">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat3x3">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat3x2">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat2x4">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat2x3">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.mat2x2">
@}
@addtogroup core_types
@{

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a></member>
        <member name="D:glm.highp_mat4x4">
4 columns of 4 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 4 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat4x4">
4 columns of 4 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 4 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat4x4">
4 columns of 4 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 4 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat4">
4 columns of 4 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 4 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat4">
4 columns of 4 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 4 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat4">
@}
@addtogroup core_precision
@{
4 columns of 4 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 4 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat4x3">
4 columns of 3 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 3 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat4x3">
4 columns of 3 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 3 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat4x3">
@}
@addtogroup core_precision
@{
4 columns of 3 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 3 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat4x2">
4 columns of 2 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 2 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat4x2">
4 columns of 2 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 2 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat4x2">
@}
@addtogroup core_precision
@{
4 columns of 2 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
4 columns of 2 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat3x4">
3 columns of 4 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 4 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat3x4">
3 columns of 4 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 4 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat3x4">
@}
@addtogroup core_precision
@{
3 columns of 4 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 4 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat3x3">
3 columns of 3 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 3 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat3x3">
3 columns of 3 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 3 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat3x3">
3 columns of 3 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 3 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat3">
3 columns of 3 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 3 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat3">
3 columns of 3 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 3 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat3">
@}
@addtogroup core_precision
@{
3 columns of 3 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 3 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat3x2">
3 columns of 2 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 2 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat3x2">
3 columns of 2 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 2 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat3x2">
@}
@addtogroup core_precision
@{
3 columns of 2 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
3 columns of 2 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat2x4">
2 columns of 4 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 4 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat2x4">
2 columns of 4 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 4 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat2x4">
@}
@addtogroup core_precision
@{
2 columns of 4 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 4 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat2x3">
2 columns of 3 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 3 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat2x3">
2 columns of 3 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 3 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat2x3">
@}
@addtogroup core_precision
@{
2 columns of 3 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 3 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat2x2">
2 columns of 2 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 2 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat2x2">
2 columns of 2 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 2 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat2x2">
2 columns of 2 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 2 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_mat2">
2 columns of 2 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 2 components matrix of high precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_mat2">
2 columns of 2 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 2 components matrix of medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_mat2">
@addtogroup core_precision
@{
2 columns of 2 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
2 columns of 2 components matrix of low precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.bvec4">
4 components vector of boolean.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.bvec3">
3 components vector of boolean.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.bvec2">
2 components vector of boolean.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.uvec4">
4 components vector of unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.uvec3">
3 components vector of unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.uvec2">
2 components vector of unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.ivec4">
4 components vector of signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.ivec3">
3 components vector of signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.ivec2">
2 components vector of signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.dvec4">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.dvec3">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.dvec2">
2 components vector of double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.vec4">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.vec3">

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.vec2">
@}
@addtogroup core_types
@{
2 components vector of floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a></member>
        <member name="D:glm.lowp_bvec4">
4 components vector of low precision bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_bvec4">
4 components vector of medium precision bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_bvec4">
4 components vector of high precision bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_uvec4">
4 components vector of low precision unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_uvec4">
4 components vector of medium precision unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_uvec4">
4 components vector of high precision unsigned integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_ivec4">
4 components vector of low precision signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_ivec4">
4 components vector of medium precision signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_ivec4">
4 components vector of high precision signed integer numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dvec4">
4 components vector of low double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dvec4">
4 components vector of medium double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dvec4">
4 components vector of high double-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_vec4">
4 components vector of low single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
Low single-precision floating-point vector of 4 components.
@see core_precision
</member>
        <member name="D:glm.mediump_vec4">
4 components vector of medium single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
Medium Single-precision floating-point vector of 4 components.
@see core_precision
</member>
        <member name="D:glm.highp_vec4">
@}
@addtogroup core_precision
@{
4 components vector of high single-precision floating-point numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
High Single-precision floating-point vector of 4 components.
@see core_precision
</member>
        <member name="D:glm.lowp_bvec3">
3 components vector of low precision bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_bvec3">
3 components vector of medium precision bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_bvec3">
3 components vector of high precision bool numbers.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_uvec3">
3 components vector of low precision unsigned integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_uvec3">
3 components vector of medium precision unsigned integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_uvec3">
3 components vector of high precision unsigned integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_ivec3">
3 components vector of low precision signed integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_ivec3">
3 components vector of medium precision signed integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_ivec3">
3 components vector of high precision signed integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dvec3">
3 components vector of low double-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dvec3">
3 components vector of medium double-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dvec3">
3 components vector of high double-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_vec3">
3 components vector of low single-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
Low single-precision floating-point vector of 3 components.
@see core_precision
</member>
        <member name="D:glm.mediump_vec3">
3 components vector of medium single-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
Medium Single-precision floating-point vector of 3 components.
@see core_precision
</member>
        <member name="D:glm.highp_vec3">
@}
@addtogroup core_precision
@{
3 components vector of high single-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
High Single-precision floating-point vector of 3 components.
@see core_precision
</member>
        <member name="D:glm.lowp_bvec2">
2 components vector of low precision bool numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_bvec2">
2 components vector of medium precision bool numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_bvec2">
2 components vector of high precision bool numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_uvec2">
2 components vector of low precision unsigned integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_uvec2">
2 components vector of medium precision unsigned integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_uvec2">
2 components vector of high precision unsigned integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_ivec2">
2 components vector of low precision signed integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_ivec2">
2 components vector of medium precision signed integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_ivec2">
2 components vector of high precision signed integer numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_dvec2">
2 components vector of low double-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_dvec2">
2 components vector of medium double-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_dvec2">
2 components vector of high double-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_vec2">
2 components vector of low single-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
Low single-precision floating-point vector of 2 components.
@see core_precision
</member>
        <member name="D:glm.mediump_vec2">
2 components vector of medium single-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
Medium Single-precision floating-point vector of 2 components.
@see core_precision
</member>
        <member name="D:glm.highp_vec2">
@addtogroup core_precision
@{
2 components vector of high single-precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
High Single-precision floating-point vector of 2 components.
@see core_precision
</member>
        <member name="D:glm.highp_float">
High precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.4 Floats</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_float">
Medium precision floating-point numbers.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.4 Floats</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_float">
@addtogroup core_precision
@{
Low precision floating-point numbers. 
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.4 Floats</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.uint">
Unsigned integer type.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a></member>
        <member name="D:glm.highp_uint">
High precision unsigned integer. 
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_uint">
Medium precision unsigned integer. 
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_uint">
Low precision unsigned integer. 
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.highp_int">
High precision signed integer.
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.mediump_int">
Medium precision signed integer. 
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="D:glm.lowp_int">
@addtogroup core_precision
@{
Low precision signed integer. 
There is no guarantee on the actual precision.

@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
@see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a></member>
        <member name="T:__m64">
@ref simd
@file glm/simd/platform.h
</member>
        <member name="M:_wassert(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
@ref core
@file glm/fwd.hpp
@ref core
@file glm/detail/type_int.hpp
@ref core
@file glm/detail/setup.hpp

@ref core
@file glm/detail/_fixes.hpp
</member>
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiComponent" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiFace" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasVertexColors(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiAnimMesh.HasTextureCoords(System.UInt32)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiLight" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiCamera" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureOp" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiTextureType" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiShadingMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiBlendMode" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:aiMaterialProperty" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloatArray(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*,System.UInt32*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "M:aiGetMaterialFloat(aiMaterial!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32,System.Single*)" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btDefaultMotionState" wird verworfen. -->
        <!-- Der ungültige XML-Dokumentkommentar für Member "T:btConvexConvexAlgorithm" wird verworfen. -->
    </members>
</doc>